/* tslint:disable */
/* eslint-disable */
/**
 * AssistedInstall
 * Assisted installation
 *
 * OpenAPI spec version: 1.0.0
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */
import globalAxios, { AxiosResponse, AxiosInstance, AxiosRequestConfig } from 'axios';
import { Configuration } from '../configuration';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from '../base';
import { BindHostParams } from '../models';
import { Cluster } from '../models';
import { ClusterCreateParams } from '../models';
import { ClusterDefaultConfig } from '../models';
import { ClusterList } from '../models';
import { CompletionParams } from '../models';
import { Credentials } from '../models';
import { FeatureSupportLevels } from '../models';
import { Host } from '../models';
import { HostCreateParams } from '../models';
import { HostIgnitionParams } from '../models';
import { HostList } from '../models';
import { HostProgress } from '../models';
import { HostRegistrationResponse } from '../models';
import { HostUpdateParams } from '../models';
import { IgnoredValidations } from '../models';
import { ImportClusterParams } from '../models';
import { InfraEnv } from '../models';
import { InfraEnvCreateParams } from '../models';
import { InfraEnvList } from '../models';
import { InfraEnvUpdateParams } from '../models';
import { InfraError } from '../models';
import { InlineResponse200 } from '../models';
import { InlineResponse2001 } from '../models';
import { InstallerArgsParams } from '../models';
import { LogsProgressParams } from '../models';
import { MonitoredOperatorsList } from '../models';
import { OperatorMonitorReport } from '../models';
import { PlatformType } from '../models';
import { PreflightHardwareRequirements } from '../models';
import { PresignedUrl } from '../models';
import { StepReply } from '../models';
import { Steps } from '../models';
import { V2ClusterUpdateParams } from '../models';
/**
 * InstallerApi - axios parameter creator
 * @export
 */
export const InstallerApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Bind host to a cluster
     * @param {BindHostParams} body The parameters for the host binding.
     * @param {string} infraEnvId The infra-env of the host that is being bound.
     * @param {string} hostId The host that is being bound.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    bindHost: async (
      body: BindHostParams,
      infraEnvId: string,
      hostId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling bindHost.',
        );
      }
      // verify required parameter 'infraEnvId' is not null or undefined
      if (infraEnvId === null || infraEnvId === undefined) {
        throw new RequiredError(
          'infraEnvId',
          'Required parameter infraEnvId was null or undefined when calling bindHost.',
        );
      }
      // verify required parameter 'hostId' is not null or undefined
      if (hostId === null || hostId === undefined) {
        throw new RequiredError(
          'hostId',
          'Required parameter hostId was null or undefined when calling bindHost.',
        );
      }
      const localVarPath = `/v2/infra-envs/{infra_env_id}/hosts/{host_id}/actions/bind`
        .replace(`{${'infra_env_id'}}`, encodeURIComponent(String(infraEnvId)))
        .replace(`{${'host_id'}}`, encodeURIComponent(String(hostId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes an infra-env.
     * @param {string} infraEnvId The infra-env to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    deregisterInfraEnv: async (
      infraEnvId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      if (infraEnvId === null || infraEnvId === undefined) {
        throw new RequiredError(
          'infraEnvId',
          'Required parameter infraEnvId was null or undefined when calling deregisterInfraEnv.',
        );
      }
      const localVarPath = `/v2/infra-envs/{infra_env_id}`.replace(
        `{${'infra_env_id'}}`,
        encodeURIComponent(String(infraEnvId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the initial ramdisk for minimal ISO based installations.
     * @param {string} infraEnvId The infra-env of the host that should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    downloadMinimalInitrd: async (
      infraEnvId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      if (infraEnvId === null || infraEnvId === undefined) {
        throw new RequiredError(
          'infraEnvId',
          'Required parameter infraEnvId was null or undefined when calling downloadMinimalInitrd.',
        );
      }
      const localVarPath = `/v2/infra-envs/{infra_env_id}/downloads/minimal-initrd`.replace(
        `{${'infra_env_id'}}`,
        encodeURIComponent(String(infraEnvId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication imageAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Image-Token')
            : await configuration.apiKey;
        localVarHeaderParameter['Image-Token'] = localVarApiKeyValue;
      }

      // authentication urlAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('api_key')
            : await configuration.apiKey;
        localVarQueryParameter['api_key'] = localVarApiKeyValue;
      }

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * A list of platforms that this cluster can support in its current configuration.
     * @param {string} clusterId The cluster whose platform types should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getClusterSupportedPlatforms: async (
      clusterId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      if (clusterId === null || clusterId === undefined) {
        throw new RequiredError(
          'clusterId',
          'Required parameter clusterId was null or undefined when calling getClusterSupportedPlatforms.',
        );
      }
      const localVarPath = `/v2/clusters/{cluster_id}/supported-platforms`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the details of the infra-env.
     * @param {string} infraEnvId The infra-env to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInfraEnv: async (
      infraEnvId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      if (infraEnvId === null || infraEnvId === undefined) {
        throw new RequiredError(
          'infraEnvId',
          'Required parameter infraEnvId was null or undefined when calling getInfraEnv.',
        );
      }
      const localVarPath = `/v2/infra-envs/{infra_env_id}`.replace(
        `{${'infra_env_id'}}`,
        encodeURIComponent(String(infraEnvId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication agentAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Secret-Key')
            : await configuration.apiKey;
        localVarHeaderParameter['X-Secret-Key'] = localVarApiKeyValue;
      }

      // authentication imageAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Image-Token')
            : await configuration.apiKey;
        localVarHeaderParameter['Image-Token'] = localVarApiKeyValue;
      }

      // authentication imageURLAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('image_token')
            : await configuration.apiKey;
        localVarQueryParameter['image_token'] = localVarApiKeyValue;
      }

      // authentication urlAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('api_key')
            : await configuration.apiKey;
        localVarQueryParameter['api_key'] = localVarApiKeyValue;
      }

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a new pre-signed image download URL for the infra-env.
     * @param {string} infraEnvId The infra-env to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInfraEnvDownloadURL: async (
      infraEnvId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      if (infraEnvId === null || infraEnvId === undefined) {
        throw new RequiredError(
          'infraEnvId',
          'Required parameter infraEnvId was null or undefined when calling getInfraEnvDownloadURL.',
        );
      }
      const localVarPath = `/v2/infra-envs/{infra_env_id}/downloads/image-url`.replace(
        `{${'infra_env_id'}}`,
        encodeURIComponent(String(infraEnvId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a new pre-signed download URL for the infra-env.
     * @param {string} infraEnvId The file&#x27;s infra-env.
     * @param {string} fileName The file to be downloaded.
     * @param {string} [ipxeScriptType] Specify the script type to be served for iPXE.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getInfraEnvPresignedFileURL: async (
      infraEnvId: string,
      fileName: string,
      ipxeScriptType?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      if (infraEnvId === null || infraEnvId === undefined) {
        throw new RequiredError(
          'infraEnvId',
          'Required parameter infraEnvId was null or undefined when calling getInfraEnvPresignedFileURL.',
        );
      }
      // verify required parameter 'fileName' is not null or undefined
      if (fileName === null || fileName === undefined) {
        throw new RequiredError(
          'fileName',
          'Required parameter fileName was null or undefined when calling getInfraEnvPresignedFileURL.',
        );
      }
      const localVarPath = `/v2/infra-envs/{infra_env_id}/downloads/files-presigned`.replace(
        `{${'infra_env_id'}}`,
        encodeURIComponent(String(infraEnvId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      if (fileName !== undefined) {
        localVarQueryParameter['file_name'] = fileName;
      }

      if (ipxeScriptType !== undefined) {
        localVarQueryParameter['ipxe_script_type'] = ipxeScriptType;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the architecture support-levels for each OpenShift version.
     * @param {string} openshiftVersion Version of the OpenShift cluster.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSupportedArchitectures: async (
      openshiftVersion: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'openshiftVersion' is not null or undefined
      if (openshiftVersion === null || openshiftVersion === undefined) {
        throw new RequiredError(
          'openshiftVersion',
          'Required parameter openshiftVersion was null or undefined when calling getSupportedArchitectures.',
        );
      }
      const localVarPath = `/v2/support-levels/architectures`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      if (openshiftVersion !== undefined) {
        localVarQueryParameter['openshift_version'] = openshiftVersion;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the features support levels for each OpenShift version.
     * @param {string} openshiftVersion Version of the OpenShift cluster.
     * @param {string} [cpuArchitecture] The CPU architecture of the image (x86_64/arm64/etc).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getSupportedFeatures: async (
      openshiftVersion: string,
      cpuArchitecture?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'openshiftVersion' is not null or undefined
      if (openshiftVersion === null || openshiftVersion === undefined) {
        throw new RequiredError(
          'openshiftVersion',
          'Required parameter openshiftVersion was null or undefined when calling getSupportedFeatures.',
        );
      }
      const localVarPath = `/v2/support-levels/features`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      if (openshiftVersion !== undefined) {
        localVarQueryParameter['openshift_version'] = openshiftVersion;
      }

      if (cpuArchitecture !== undefined) {
        localVarQueryParameter['cpu_architecture'] = cpuArchitecture;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Get a list of cluster hosts according to supplied filters.
     * @param {string} clusterId The cluster whose hosts should be retrieved.
     * @param {string} [role] Role to request.
     * @param {string} [status] Hosts status to request.
     * @param {boolean} [withInventory] If true return the host&#x27;s inventory.
     * @param {boolean} [withConnectivity] If true return the host&#x27;s connectivity.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listClusterHosts: async (
      clusterId: string,
      role?: string,
      status?: string,
      withInventory?: boolean,
      withConnectivity?: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      if (clusterId === null || clusterId === undefined) {
        throw new RequiredError(
          'clusterId',
          'Required parameter clusterId was null or undefined when calling listClusterHosts.',
        );
      }
      const localVarPath = `/v2/clusters/{cluster_id}/hosts`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication agentAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Secret-Key')
            : await configuration.apiKey;
        localVarHeaderParameter['X-Secret-Key'] = localVarApiKeyValue;
      }

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      if (role !== undefined) {
        localVarQueryParameter['role'] = role;
      }

      if (status !== undefined) {
        localVarQueryParameter['status'] = status;
      }

      if (withInventory !== undefined) {
        localVarQueryParameter['with-inventory'] = withInventory;
      }

      if (withConnectivity !== undefined) {
        localVarQueryParameter['with-connectivity'] = withConnectivity;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the list of infra-envs.
     * @param {string} [clusterId] If provided, returns only infra-envs which directly reference this cluster.
     * @param {string} [owner] If provided, returns only infra-envs that are owned by the specified user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    listInfraEnvs: async (
      clusterId?: string,
      owner?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v2/infra-envs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      if (clusterId !== undefined) {
        localVarQueryParameter['cluster_id'] = clusterId;
      }

      if (owner !== undefined) {
        localVarQueryParameter['owner'] = owner;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Regenerate InfraEnv token signing key.
     * @param {string} infraEnvId The target InfraEnv.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    regenerateInfraEnvSigningKey: async (
      infraEnvId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      if (infraEnvId === null || infraEnvId === undefined) {
        throw new RequiredError(
          'infraEnvId',
          'Required parameter infraEnvId was null or undefined when calling regenerateInfraEnvSigningKey.',
        );
      }
      const localVarPath = `/v2/infra-envs/{infra_env_id}/regenerate-signing-key`.replace(
        `{${'infra_env_id'}}`,
        encodeURIComponent(String(infraEnvId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a new OpenShift Discovery ISO.
     * @param {InfraEnvCreateParams} body The parameters for the generated ISO.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    registerInfraEnv: async (
      body: InfraEnvCreateParams,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling registerInfraEnv.',
        );
      }
      const localVarPath = `/v2/infra-envs`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Transforms installed cluster to a state which allows adding hosts.
     * @param {string} clusterId The cluster to transform.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transformClusterToAddingHosts: async (
      clusterId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      if (clusterId === null || clusterId === undefined) {
        throw new RequiredError(
          'clusterId',
          'Required parameter clusterId was null or undefined when calling transformClusterToAddingHosts.',
        );
      }
      const localVarPath = `/v2/clusters/{cluster_id}/actions/allow-add-hosts`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Deprecated, maintained for legacy purposes. Does the same thing as allow-add-hosts. Use allow-add-hosts instead.
     * @param {string} clusterId The cluster to transform.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    transformClusterToDay2: async (
      clusterId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      if (clusterId === null || clusterId === undefined) {
        throw new RequiredError(
          'clusterId',
          'Required parameter clusterId was null or undefined when calling transformClusterToDay2.',
        );
      }
      const localVarPath = `/v2/clusters/{cluster_id}/actions/allow-add-workers`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Unbind host to a cluster
     * @param {string} infraEnvId The infra-env of the host that is being bound.
     * @param {string} hostId The host that is being bound.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    unbindHost: async (
      infraEnvId: string,
      hostId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      if (infraEnvId === null || infraEnvId === undefined) {
        throw new RequiredError(
          'infraEnvId',
          'Required parameter infraEnvId was null or undefined when calling unbindHost.',
        );
      }
      // verify required parameter 'hostId' is not null or undefined
      if (hostId === null || hostId === undefined) {
        throw new RequiredError(
          'hostId',
          'Required parameter hostId was null or undefined when calling unbindHost.',
        );
      }
      const localVarPath = `/v2/infra-envs/{infra_env_id}/hosts/{host_id}/actions/unbind`
        .replace(`{${'infra_env_id'}}`, encodeURIComponent(String(infraEnvId)))
        .replace(`{${'host_id'}}`, encodeURIComponent(String(hostId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates an infra-env.
     * @param {InfraEnvUpdateParams} body The properties to update.
     * @param {string} infraEnvId The infra-env to be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    updateInfraEnv: async (
      body: InfraEnvUpdateParams,
      infraEnvId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling updateInfraEnv.',
        );
      }
      // verify required parameter 'infraEnvId' is not null or undefined
      if (infraEnvId === null || infraEnvId === undefined) {
        throw new RequiredError(
          'infraEnvId',
          'Required parameter infraEnvId was null or undefined when calling updateInfraEnv.',
        );
      }
      const localVarPath = `/v2/infra-envs/{infra_env_id}`.replace(
        `{${'infra_env_id'}}`,
        encodeURIComponent(String(infraEnvId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Cancels an ongoing installation.
     * @param {string} clusterId The cluster whose installation is to be canceled.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2CancelInstallation: async (
      clusterId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      if (clusterId === null || clusterId === undefined) {
        throw new RequiredError(
          'clusterId',
          'Required parameter clusterId was null or undefined when calling v2CancelInstallation.',
        );
      }
      const localVarPath = `/v2/clusters/{cluster_id}/actions/cancel`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Agent API to mark a finalizing installation as complete and progress to 100%.
     * @param {CompletionParams} body The final status of the cluster installation.
     * @param {string} clusterId The cluster whose installation is being completing.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is completing the installation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2CompleteInstallation: async (
      body: CompletionParams,
      clusterId: string,
      discoveryAgentVersion?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling v2CompleteInstallation.',
        );
      }
      // verify required parameter 'clusterId' is not null or undefined
      if (clusterId === null || clusterId === undefined) {
        throw new RequiredError(
          'clusterId',
          'Required parameter clusterId was null or undefined when calling v2CompleteInstallation.',
        );
      }
      const localVarPath = `/v2/clusters/{cluster_id}/actions/complete-installation`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication agentAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Secret-Key')
            : await configuration.apiKey;
        localVarHeaderParameter['X-Secret-Key'] = localVarApiKeyValue;
      }

      if (discoveryAgentVersion !== undefined && discoveryAgentVersion !== null) {
        localVarHeaderParameter['discovery_agent_version'] = String(discoveryAgentVersion);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Deletes an OpenShift cluster definition.
     * @param {string} clusterId The cluster to be deregistered.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2DeregisterCluster: async (
      clusterId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      if (clusterId === null || clusterId === undefined) {
        throw new RequiredError(
          'clusterId',
          'Required parameter clusterId was null or undefined when calling v2DeregisterCluster.',
        );
      }
      const localVarPath = `/v2/clusters/{cluster_id}`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Deregisters an OpenShift host.
     * @param {string} infraEnvId The infra-env of the host that should be deregistered.
     * @param {string} hostId The host that should be deregistered.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2DeregisterHost: async (
      infraEnvId: string,
      hostId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      if (infraEnvId === null || infraEnvId === undefined) {
        throw new RequiredError(
          'infraEnvId',
          'Required parameter infraEnvId was null or undefined when calling v2DeregisterHost.',
        );
      }
      // verify required parameter 'hostId' is not null or undefined
      if (hostId === null || hostId === undefined) {
        throw new RequiredError(
          'hostId',
          'Required parameter hostId was null or undefined when calling v2DeregisterHost.',
        );
      }
      const localVarPath = `/v2/infra-envs/{infra_env_id}/hosts/{host_id}`
        .replace(`{${'infra_env_id'}}`, encodeURIComponent(String(infraEnvId)))
        .replace(`{${'host_id'}}`, encodeURIComponent(String(hostId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'DELETE',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Downloads credentials relating to the installed/installing cluster.
     * @param {string} clusterId The cluster that owns the credential file that should be downloaded.
     * @param {string} fileName The credential file to be downloaded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2DownloadClusterCredentials: async (
      clusterId: string,
      fileName: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      if (clusterId === null || clusterId === undefined) {
        throw new RequiredError(
          'clusterId',
          'Required parameter clusterId was null or undefined when calling v2DownloadClusterCredentials.',
        );
      }
      // verify required parameter 'fileName' is not null or undefined
      if (fileName === null || fileName === undefined) {
        throw new RequiredError(
          'fileName',
          'Required parameter fileName was null or undefined when calling v2DownloadClusterCredentials.',
        );
      }
      const localVarPath = `/v2/clusters/{cluster_id}/downloads/credentials`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication agentAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Secret-Key')
            : await configuration.apiKey;
        localVarHeaderParameter['X-Secret-Key'] = localVarApiKeyValue;
      }

      // authentication urlAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('api_key')
            : await configuration.apiKey;
        localVarQueryParameter['api_key'] = localVarApiKeyValue;
      }

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      if (fileName !== undefined) {
        localVarQueryParameter['file_name'] = fileName;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Downloads files relating to the installed/installing cluster.
     * @param {string} clusterId The cluster that owns the file that should be downloaded.
     * @param {string} fileName The file to be downloaded.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is downloading the file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2DownloadClusterFiles: async (
      clusterId: string,
      fileName: string,
      discoveryAgentVersion?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      if (clusterId === null || clusterId === undefined) {
        throw new RequiredError(
          'clusterId',
          'Required parameter clusterId was null or undefined when calling v2DownloadClusterFiles.',
        );
      }
      // verify required parameter 'fileName' is not null or undefined
      if (fileName === null || fileName === undefined) {
        throw new RequiredError(
          'fileName',
          'Required parameter fileName was null or undefined when calling v2DownloadClusterFiles.',
        );
      }
      const localVarPath = `/v2/clusters/{cluster_id}/downloads/files`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication agentAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Secret-Key')
            : await configuration.apiKey;
        localVarHeaderParameter['X-Secret-Key'] = localVarApiKeyValue;
      }

      // authentication urlAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('api_key')
            : await configuration.apiKey;
        localVarQueryParameter['api_key'] = localVarApiKeyValue;
      }

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      if (fileName !== undefined) {
        localVarQueryParameter['file_name'] = fileName;
      }

      if (discoveryAgentVersion !== undefined && discoveryAgentVersion !== null) {
        localVarHeaderParameter['discovery_agent_version'] = String(discoveryAgentVersion);
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Download cluster logs.
     * @param {string} clusterId The cluster whose logs should be downloaded.
     * @param {string} [logsType] The type of logs to be downloaded.
     * @param {string} [hostId] A specific host in the cluster whose logs should be downloaded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2DownloadClusterLogs: async (
      clusterId: string,
      logsType?: string,
      hostId?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      if (clusterId === null || clusterId === undefined) {
        throw new RequiredError(
          'clusterId',
          'Required parameter clusterId was null or undefined when calling v2DownloadClusterLogs.',
        );
      }
      const localVarPath = `/v2/clusters/{cluster_id}/logs`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication urlAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('api_key')
            : await configuration.apiKey;
        localVarQueryParameter['api_key'] = localVarApiKeyValue;
      }

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      if (logsType !== undefined) {
        localVarQueryParameter['logs_type'] = logsType;
      }

      if (hostId !== undefined) {
        localVarQueryParameter['host_id'] = hostId;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Downloads the customized ignition file for this bound host, produces octet stream. For unbound host - error is returned
     * @param {string} infraEnvId The infra-env of the host whose ignition file should be downloaded.
     * @param {string} hostId The host whose ignition file should be downloaded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2DownloadHostIgnition: async (
      infraEnvId: string,
      hostId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      if (infraEnvId === null || infraEnvId === undefined) {
        throw new RequiredError(
          'infraEnvId',
          'Required parameter infraEnvId was null or undefined when calling v2DownloadHostIgnition.',
        );
      }
      // verify required parameter 'hostId' is not null or undefined
      if (hostId === null || hostId === undefined) {
        throw new RequiredError(
          'hostId',
          'Required parameter hostId was null or undefined when calling v2DownloadHostIgnition.',
        );
      }
      const localVarPath = `/v2/infra-env/{infra_env_id}/hosts/{host_id}/downloads/ignition`
        .replace(`{${'infra_env_id'}}`, encodeURIComponent(String(infraEnvId)))
        .replace(`{${'host_id'}}`, encodeURIComponent(String(hostId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication agentAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Secret-Key')
            : await configuration.apiKey;
        localVarHeaderParameter['X-Secret-Key'] = localVarApiKeyValue;
      }

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Downloads the customized ignition file for this host
     * @param {string} infraEnvId The infra-env whose file should be downloaded.
     * @param {string} fileName The file to be downloaded.
     * @param {string} [mac] Mac address of the host running ipxe script.
     * @param {string} [ipxeScriptType] Specify the script type to be served for iPXE.
     * @param {string} [discoveryIsoType] Overrides the ISO type for the disovery ignition, either &#x27;full-iso&#x27; or &#x27;minimal-iso&#x27;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2DownloadInfraEnvFiles: async (
      infraEnvId: string,
      fileName: string,
      mac?: string,
      ipxeScriptType?: string,
      discoveryIsoType?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      if (infraEnvId === null || infraEnvId === undefined) {
        throw new RequiredError(
          'infraEnvId',
          'Required parameter infraEnvId was null or undefined when calling v2DownloadInfraEnvFiles.',
        );
      }
      // verify required parameter 'fileName' is not null or undefined
      if (fileName === null || fileName === undefined) {
        throw new RequiredError(
          'fileName',
          'Required parameter fileName was null or undefined when calling v2DownloadInfraEnvFiles.',
        );
      }
      const localVarPath = `/v2/infra-envs/{infra_env_id}/downloads/files`.replace(
        `{${'infra_env_id'}}`,
        encodeURIComponent(String(infraEnvId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication agentAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Secret-Key')
            : await configuration.apiKey;
        localVarHeaderParameter['X-Secret-Key'] = localVarApiKeyValue;
      }

      // authentication imageAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Image-Token')
            : await configuration.apiKey;
        localVarHeaderParameter['Image-Token'] = localVarApiKeyValue;
      }

      // authentication imageURLAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('image_token')
            : await configuration.apiKey;
        localVarQueryParameter['image_token'] = localVarApiKeyValue;
      }

      // authentication urlAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('api_key')
            : await configuration.apiKey;
        localVarQueryParameter['api_key'] = localVarApiKeyValue;
      }

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      if (fileName !== undefined) {
        localVarQueryParameter['file_name'] = fileName;
      }

      if (mac !== undefined) {
        localVarQueryParameter['mac'] = mac;
      }

      if (ipxeScriptType !== undefined) {
        localVarQueryParameter['ipxe_script_type'] = ipxeScriptType;
      }

      if (discoveryIsoType !== undefined) {
        localVarQueryParameter['discovery_iso_type'] = discoveryIsoType;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the details of the OpenShift cluster.
     * @param {string} clusterId The cluster to be retrieved.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is retrieving the cluster details.
     * @param {boolean} [getUnregisteredClusters] Whether to return clusters that have been unregistered.
     * @param {boolean} [excludeHosts] If true, do not include hosts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2GetCluster: async (
      clusterId: string,
      discoveryAgentVersion?: string,
      getUnregisteredClusters?: boolean,
      excludeHosts?: boolean,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      if (clusterId === null || clusterId === undefined) {
        throw new RequiredError(
          'clusterId',
          'Required parameter clusterId was null or undefined when calling v2GetCluster.',
        );
      }
      const localVarPath = `/v2/clusters/{cluster_id}`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication agentAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Secret-Key')
            : await configuration.apiKey;
        localVarHeaderParameter['X-Secret-Key'] = localVarApiKeyValue;
      }

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      if (excludeHosts !== undefined) {
        localVarQueryParameter['exclude-hosts'] = excludeHosts;
      }

      if (discoveryAgentVersion !== undefined && discoveryAgentVersion !== null) {
        localVarHeaderParameter['discovery_agent_version'] = String(discoveryAgentVersion);
      }

      if (getUnregisteredClusters !== undefined && getUnregisteredClusters !== null) {
        localVarHeaderParameter['get_unregistered_clusters'] = String(
          JSON.stringify(getUnregisteredClusters),
        );
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the default values for various cluster properties.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2GetClusterDefaultConfig: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v2/clusters/default-config`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the cluster's install config YAML.
     * @param {string} clusterId The cluster whose install config is being retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2GetClusterInstallConfig: async (
      clusterId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      if (clusterId === null || clusterId === undefined) {
        throw new RequiredError(
          'clusterId',
          'Required parameter clusterId was null or undefined when calling v2GetClusterInstallConfig.',
        );
      }
      const localVarPath = `/v2/clusters/{cluster_id}/install-config`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the cluster admin credentials.
     * @param {string} clusterId The cluster whose admin credentials should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2GetCredentials: async (
      clusterId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      if (clusterId === null || clusterId === undefined) {
        throw new RequiredError(
          'clusterId',
          'Required parameter clusterId was null or undefined when calling v2GetCredentials.',
        );
      }
      const localVarPath = `/v2/clusters/{cluster_id}/credentials`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the details of the OpenShift host.
     * @param {string} infraEnvId The infra-env of the host that should be retrieved.
     * @param {string} hostId The host that should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2GetHost: async (
      infraEnvId: string,
      hostId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      if (infraEnvId === null || infraEnvId === undefined) {
        throw new RequiredError(
          'infraEnvId',
          'Required parameter infraEnvId was null or undefined when calling v2GetHost.',
        );
      }
      // verify required parameter 'hostId' is not null or undefined
      if (hostId === null || hostId === undefined) {
        throw new RequiredError(
          'hostId',
          'Required parameter hostId was null or undefined when calling v2GetHost.',
        );
      }
      const localVarPath = `/v2/infra-envs/{infra_env_id}/hosts/{host_id}`
        .replace(`{${'infra_env_id'}}`, encodeURIComponent(String(infraEnvId)))
        .replace(`{${'host_id'}}`, encodeURIComponent(String(hostId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetch the ignition file for this host as a string. In case of unbound host produces an error
     * @param {string} infraEnvId The infra-env of the host whose ignition file should be obtained.
     * @param {string} hostId The host whose ignition file should be obtained.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2GetHostIgnition: async (
      infraEnvId: string,
      hostId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      if (infraEnvId === null || infraEnvId === undefined) {
        throw new RequiredError(
          'infraEnvId',
          'Required parameter infraEnvId was null or undefined when calling v2GetHostIgnition.',
        );
      }
      // verify required parameter 'hostId' is not null or undefined
      if (hostId === null || hostId === undefined) {
        throw new RequiredError(
          'hostId',
          'Required parameter hostId was null or undefined when calling v2GetHostIgnition.',
        );
      }
      const localVarPath = `/v2/infra-envs/{infra_env_id}/hosts/{host_id}/ignition`
        .replace(`{${'infra_env_id'}}`, encodeURIComponent(String(infraEnvId)))
        .replace(`{${'host_id'}}`, encodeURIComponent(String(hostId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Fetch the validations which are to be ignored for this cluster.
     * @param {string} clusterId The cluster whose failing validations should be ignored according to this list.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2GetIgnoredValidations: async (
      clusterId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      if (clusterId === null || clusterId === undefined) {
        throw new RequiredError(
          'clusterId',
          'Required parameter clusterId was null or undefined when calling v2GetIgnoredValidations.',
        );
      }
      const localVarPath = `/v2/clusters/{cluster_id}/ignored-validations`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the next operations that the host agent needs to perform.
     * @param {string} infraEnvId The infra-env of the host that is retrieving instructions.
     * @param {string} hostId The host that is retrieving instructions.
     * @param {number} [timestamp] The time on the host as seconds since the Unix epoch.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is retrieving instructions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2GetNextSteps: async (
      infraEnvId: string,
      hostId: string,
      timestamp?: number,
      discoveryAgentVersion?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      if (infraEnvId === null || infraEnvId === undefined) {
        throw new RequiredError(
          'infraEnvId',
          'Required parameter infraEnvId was null or undefined when calling v2GetNextSteps.',
        );
      }
      // verify required parameter 'hostId' is not null or undefined
      if (hostId === null || hostId === undefined) {
        throw new RequiredError(
          'hostId',
          'Required parameter hostId was null or undefined when calling v2GetNextSteps.',
        );
      }
      const localVarPath = `/v2/infra-envs/{infra_env_id}/hosts/{host_id}/instructions`
        .replace(`{${'infra_env_id'}}`, encodeURIComponent(String(infraEnvId)))
        .replace(`{${'host_id'}}`, encodeURIComponent(String(hostId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication agentAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Secret-Key')
            : await configuration.apiKey;
        localVarHeaderParameter['X-Secret-Key'] = localVarApiKeyValue;
      }

      if (timestamp !== undefined) {
        localVarQueryParameter['timestamp'] = timestamp;
      }

      if (discoveryAgentVersion !== undefined && discoveryAgentVersion !== null) {
        localVarHeaderParameter['discovery_agent_version'] = String(discoveryAgentVersion);
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Get preflight requirements for a cluster.
     * @param {string} clusterId The cluster to return preflight requirements for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2GetPreflightRequirements: async (
      clusterId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      if (clusterId === null || clusterId === undefined) {
        throw new RequiredError(
          'clusterId',
          'Required parameter clusterId was null or undefined when calling v2GetPreflightRequirements.',
        );
      }
      const localVarPath = `/v2/clusters/{cluster_id}/preflight-requirements`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Get the cluster admin credentials.
     * @param {string} clusterId The cluster that owns the file that should be downloaded.
     * @param {string} fileName The file to be downloaded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2GetPresignedForClusterCredentials: async (
      clusterId: string,
      fileName: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      if (clusterId === null || clusterId === undefined) {
        throw new RequiredError(
          'clusterId',
          'Required parameter clusterId was null or undefined when calling v2GetPresignedForClusterCredentials.',
        );
      }
      // verify required parameter 'fileName' is not null or undefined
      if (fileName === null || fileName === undefined) {
        throw new RequiredError(
          'fileName',
          'Required parameter fileName was null or undefined when calling v2GetPresignedForClusterCredentials.',
        );
      }
      const localVarPath = `/v2/clusters/{cluster_id}/downloads/credentials-presigned`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      if (fileName !== undefined) {
        localVarQueryParameter['file_name'] = fileName;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves a pre-signed S3 URL for downloading cluster files.
     * @param {string} clusterId The cluster that owns the file that should be downloaded.
     * @param {string} fileName The file to be downloaded.
     * @param {string} [logsType] If downloading logs, the type of logs to download.
     * @param {string} [hostId] If downloading a file related to a host, the relevant host.
     * @param {string} [additionalName] If downloading a manifest, the file name, prefaced with folder name, for example, openshift/99-openshift-xyz.yaml.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2GetPresignedForClusterFiles: async (
      clusterId: string,
      fileName: string,
      logsType?: string,
      hostId?: string,
      additionalName?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      if (clusterId === null || clusterId === undefined) {
        throw new RequiredError(
          'clusterId',
          'Required parameter clusterId was null or undefined when calling v2GetPresignedForClusterFiles.',
        );
      }
      // verify required parameter 'fileName' is not null or undefined
      if (fileName === null || fileName === undefined) {
        throw new RequiredError(
          'fileName',
          'Required parameter fileName was null or undefined when calling v2GetPresignedForClusterFiles.',
        );
      }
      const localVarPath = `/v2/clusters/{cluster_id}/downloads/files-presigned`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      if (fileName !== undefined) {
        localVarQueryParameter['file_name'] = fileName;
      }

      if (logsType !== undefined) {
        localVarQueryParameter['logs_type'] = logsType;
      }

      if (hostId !== undefined) {
        localVarQueryParameter['host_id'] = hostId;
      }

      if (additionalName !== undefined) {
        localVarQueryParameter['additional_name'] = additionalName;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Import an AI cluster using minimal data associated with existing OCP cluster, in order to allow adding day2 hosts to that cluster
     * @param {ImportClusterParams} body Parameters for importing a OCP cluster for adding nodes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2ImportCluster: async (
      body: ImportClusterParams,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling v2ImportCluster.',
        );
      }
      const localVarPath = `/v2/clusters/import`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Installs the OpenShift cluster.
     * @param {string} clusterId The cluster to be installed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2InstallCluster: async (
      clusterId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      if (clusterId === null || clusterId === undefined) {
        throw new RequiredError(
          'clusterId',
          'Required parameter clusterId was null or undefined when calling v2InstallCluster.',
        );
      }
      const localVarPath = `/v2/clusters/{cluster_id}/actions/install`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * install specific host for day2 cluster.
     * @param {string} infraEnvId The infra-env of the host that is being installed.
     * @param {string} hostId The host that is being installed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2InstallHost: async (
      infraEnvId: string,
      hostId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      if (infraEnvId === null || infraEnvId === undefined) {
        throw new RequiredError(
          'infraEnvId',
          'Required parameter infraEnvId was null or undefined when calling v2InstallHost.',
        );
      }
      // verify required parameter 'hostId' is not null or undefined
      if (hostId === null || hostId === undefined) {
        throw new RequiredError(
          'hostId',
          'Required parameter hostId was null or undefined when calling v2InstallHost.',
        );
      }
      const localVarPath = `/v2/infra-envs/{infra_env_id}/hosts/{host_id}/actions/install`
        .replace(`{${'infra_env_id'}}`, encodeURIComponent(String(infraEnvId)))
        .replace(`{${'host_id'}}`, encodeURIComponent(String(hostId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the list of OpenShift clusters.
     * @param {boolean} [getUnregisteredClusters] Whether to return clusters that have been unregistered.
     * @param {string} [openshiftClusterId] A specific cluster to retrieve.
     * @param {Array<string>} [amsSubscriptionIds] If non-empty, returned Clusters are filtered to those with matching subscription IDs.
     * @param {boolean} [withHosts] Include hosts in the returned list.
     * @param {string} [owner] If provided, returns only clusters that are owned by the specified user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2ListClusters: async (
      getUnregisteredClusters?: boolean,
      openshiftClusterId?: string,
      amsSubscriptionIds?: Array<string>,
      withHosts?: boolean,
      owner?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/v2/clusters`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      if (openshiftClusterId !== undefined) {
        localVarQueryParameter['openshift_cluster_id'] = openshiftClusterId;
      }

      if (amsSubscriptionIds) {
        localVarQueryParameter['ams_subscription_ids'] = amsSubscriptionIds.join(
          COLLECTION_FORMATS.csv,
        );
      }

      if (withHosts !== undefined) {
        localVarQueryParameter['with_hosts'] = withHosts;
      }

      if (owner !== undefined) {
        localVarQueryParameter['owner'] = owner;
      }

      if (getUnregisteredClusters !== undefined && getUnregisteredClusters !== null) {
        localVarHeaderParameter['get_unregistered_clusters'] = String(
          JSON.stringify(getUnregisteredClusters),
        );
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * (DEPRECATED) Retrieves the support levels for features for each OpenShift version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2ListFeatureSupportLevels: async (options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
      const localVarPath = `/v2/feature-support-levels`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Retrieves the list of OpenShift hosts that belong the infra-env.
     * @param {string} infraEnvId The infra-env that the hosts are asociated with.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2ListHosts: async (
      infraEnvId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      if (infraEnvId === null || infraEnvId === undefined) {
        throw new RequiredError(
          'infraEnvId',
          'Required parameter infraEnvId was null or undefined when calling v2ListHosts.',
        );
      }
      const localVarPath = `/v2/infra-envs/{infra_env_id}/hosts`.replace(
        `{${'infra_env_id'}}`,
        encodeURIComponent(String(infraEnvId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication agentAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Secret-Key')
            : await configuration.apiKey;
        localVarHeaderParameter['X-Secret-Key'] = localVarApiKeyValue;
      }

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Lists operators to be monitored for a cluster.
     * @param {string} clusterId The cluster to return operators for.
     * @param {string} [operatorName] An operator in the specified cluster to return its data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2ListOfClusterOperators: async (
      clusterId: string,
      operatorName?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      if (clusterId === null || clusterId === undefined) {
        throw new RequiredError(
          'clusterId',
          'Required parameter clusterId was null or undefined when calling v2ListOfClusterOperators.',
        );
      }
      const localVarPath = `/v2/clusters/{cluster_id}/monitored-operators`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'GET',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication agentAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Secret-Key')
            : await configuration.apiKey;
        localVarHeaderParameter['X-Secret-Key'] = localVarApiKeyValue;
      }

      if (operatorName !== undefined) {
        localVarQueryParameter['operator_name'] = operatorName;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Posts the result of the operations from the host agent.
     * @param {string} infraEnvId The infra-env of the host that is posting results.
     * @param {string} hostId The host that is posting results.
     * @param {StepReply} [body] The results to be posted.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is posting results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2PostStepReply: async (
      infraEnvId: string,
      hostId: string,
      body?: StepReply,
      discoveryAgentVersion?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      if (infraEnvId === null || infraEnvId === undefined) {
        throw new RequiredError(
          'infraEnvId',
          'Required parameter infraEnvId was null or undefined when calling v2PostStepReply.',
        );
      }
      // verify required parameter 'hostId' is not null or undefined
      if (hostId === null || hostId === undefined) {
        throw new RequiredError(
          'hostId',
          'Required parameter hostId was null or undefined when calling v2PostStepReply.',
        );
      }
      const localVarPath = `/v2/infra-envs/{infra_env_id}/hosts/{host_id}/instructions`
        .replace(`{${'infra_env_id'}}`, encodeURIComponent(String(infraEnvId)))
        .replace(`{${'host_id'}}`, encodeURIComponent(String(hostId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication agentAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Secret-Key')
            : await configuration.apiKey;
        localVarHeaderParameter['X-Secret-Key'] = localVarApiKeyValue;
      }

      if (discoveryAgentVersion !== undefined && discoveryAgentVersion !== null) {
        localVarHeaderParameter['discovery_agent_version'] = String(discoveryAgentVersion);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Creates a new OpenShift cluster definition.
     * @param {ClusterCreateParams} body The properties describing the new cluster.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2RegisterCluster: async (
      body: ClusterCreateParams,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling v2RegisterCluster.',
        );
      }
      const localVarPath = `/v2/clusters`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Registers a new OpenShift agent.
     * @param {HostCreateParams} body The description of the agent being registered.
     * @param {string} infraEnvId The infra-env that the agent is associated with.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is registering the agent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2RegisterHost: async (
      body: HostCreateParams,
      infraEnvId: string,
      discoveryAgentVersion?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling v2RegisterHost.',
        );
      }
      // verify required parameter 'infraEnvId' is not null or undefined
      if (infraEnvId === null || infraEnvId === undefined) {
        throw new RequiredError(
          'infraEnvId',
          'Required parameter infraEnvId was null or undefined when calling v2RegisterHost.',
        );
      }
      const localVarPath = `/v2/infra-envs/{infra_env_id}/hosts`.replace(
        `{${'infra_env_id'}}`,
        encodeURIComponent(String(infraEnvId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication agentAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Secret-Key')
            : await configuration.apiKey;
        localVarHeaderParameter['X-Secret-Key'] = localVarApiKeyValue;
      }

      if (discoveryAgentVersion !== undefined && discoveryAgentVersion !== null) {
        localVarHeaderParameter['discovery_agent_version'] = String(discoveryAgentVersion);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Controller API to report of monitored operators.
     * @param {OperatorMonitorReport} body The operators monitor report.
     * @param {string} clusterId The cluster whose operators are being monitored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2ReportMonitoredOperatorStatus: async (
      body: OperatorMonitorReport,
      clusterId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling v2ReportMonitoredOperatorStatus.',
        );
      }
      // verify required parameter 'clusterId' is not null or undefined
      if (clusterId === null || clusterId === undefined) {
        throw new RequiredError(
          'clusterId',
          'Required parameter clusterId was null or undefined when calling v2ReportMonitoredOperatorStatus.',
        );
      }
      const localVarPath = `/v2/clusters/{cluster_id}/monitored-operators`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication agentAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Secret-Key')
            : await configuration.apiKey;
        localVarHeaderParameter['X-Secret-Key'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Resets a failed installation.
     * @param {string} clusterId The cluster whose installation is to be reset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2ResetCluster: async (
      clusterId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'clusterId' is not null or undefined
      if (clusterId === null || clusterId === undefined) {
        throw new RequiredError(
          'clusterId',
          'Required parameter clusterId was null or undefined when calling v2ResetCluster.',
        );
      }
      const localVarPath = `/v2/clusters/{cluster_id}/actions/reset`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * reset a failed host for day2 cluster.
     * @param {string} infraEnvId The infra-env of the host that is being reset.
     * @param {string} hostId The host that is being reset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2ResetHost: async (
      infraEnvId: string,
      hostId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      if (infraEnvId === null || infraEnvId === undefined) {
        throw new RequiredError(
          'infraEnvId',
          'Required parameter infraEnvId was null or undefined when calling v2ResetHost.',
        );
      }
      // verify required parameter 'hostId' is not null or undefined
      if (hostId === null || hostId === undefined) {
        throw new RequiredError(
          'hostId',
          'Required parameter hostId was null or undefined when calling v2ResetHost.',
        );
      }
      const localVarPath = `/v2/infra-envs/{infra_env_id}/hosts/{host_id}/actions/reset`
        .replace(`{${'infra_env_id'}}`, encodeURIComponent(String(infraEnvId)))
        .replace(`{${'host_id'}}`, encodeURIComponent(String(hostId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Reset failed host validation. It may be performed on any host validation with persistent validation result.
     * @summary Reset failed host validation.
     * @param {string} infraEnvId The infra-env of the host that its validation is being reset.
     * @param {string} hostId The host that its validation is being reset.
     * @param {string} validationId The id of the validation being reset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2ResetHostValidation: async (
      infraEnvId: string,
      hostId: string,
      validationId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'infraEnvId' is not null or undefined
      if (infraEnvId === null || infraEnvId === undefined) {
        throw new RequiredError(
          'infraEnvId',
          'Required parameter infraEnvId was null or undefined when calling v2ResetHostValidation.',
        );
      }
      // verify required parameter 'hostId' is not null or undefined
      if (hostId === null || hostId === undefined) {
        throw new RequiredError(
          'hostId',
          'Required parameter hostId was null or undefined when calling v2ResetHostValidation.',
        );
      }
      // verify required parameter 'validationId' is not null or undefined
      if (validationId === null || validationId === undefined) {
        throw new RequiredError(
          'validationId',
          'Required parameter validationId was null or undefined when calling v2ResetHostValidation.',
        );
      }
      const localVarPath =
        `/v2/infra-envs/{infra_env_id}/hosts/{host_id}/actions/reset-validation/{validation_id}`
          .replace(`{${'infra_env_id'}}`, encodeURIComponent(String(infraEnvId)))
          .replace(`{${'host_id'}}`, encodeURIComponent(String(hostId)))
          .replace(`{${'validation_id'}}`, encodeURIComponent(String(validationId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Register the validations which are to be ignored for this cluster.
     * @param {IgnoredValidations} body The validations to be ignored.
     * @param {string} clusterId The cluster whose failing validations should be ignored according to this list.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2SetIgnoredValidations: async (
      body: IgnoredValidations,
      clusterId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling v2SetIgnoredValidations.',
        );
      }
      // verify required parameter 'clusterId' is not null or undefined
      if (clusterId === null || clusterId === undefined) {
        throw new RequiredError(
          'clusterId',
          'Required parameter clusterId was null or undefined when calling v2SetIgnoredValidations.',
        );
      }
      const localVarPath = `/v2/clusters/{cluster_id}/ignored-validations`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates an OpenShift cluster definition.
     * @param {V2ClusterUpdateParams} body The properties to update.
     * @param {string} clusterId The cluster to be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2UpdateCluster: async (
      body: V2ClusterUpdateParams,
      clusterId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling v2UpdateCluster.',
        );
      }
      // verify required parameter 'clusterId' is not null or undefined
      if (clusterId === null || clusterId === undefined) {
        throw new RequiredError(
          'clusterId',
          'Required parameter clusterId was null or undefined when calling v2UpdateCluster.',
        );
      }
      const localVarPath = `/v2/clusters/{cluster_id}`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Override values in the install config.
     * @param {string} body Install config overrides.
     * @param {string} clusterId The cluster whose install config is being updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2UpdateClusterInstallConfig: async (
      body: string,
      clusterId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling v2UpdateClusterInstallConfig.',
        );
      }
      // verify required parameter 'clusterId' is not null or undefined
      if (clusterId === null || clusterId === undefined) {
        throw new RequiredError(
          'clusterId',
          'Required parameter clusterId was null or undefined when calling v2UpdateClusterInstallConfig.',
        );
      }
      const localVarPath = `/v2/clusters/{cluster_id}/install-config`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Update log collection state and progress.
     * @param {LogsProgressParams} body Parameters for updating log progress.
     * @param {string} clusterId The cluster whose log progress is being updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2UpdateClusterLogsProgress: async (
      body: LogsProgressParams,
      clusterId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling v2UpdateClusterLogsProgress.',
        );
      }
      // verify required parameter 'clusterId' is not null or undefined
      if (clusterId === null || clusterId === undefined) {
        throw new RequiredError(
          'clusterId',
          'Required parameter clusterId was null or undefined when calling v2UpdateClusterLogsProgress.',
        );
      }
      const localVarPath = `/v2/clusters/{cluster_id}/logs-progress`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication agentAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Secret-Key')
            : await configuration.apiKey;
        localVarHeaderParameter['X-Secret-Key'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Update an Openshift host
     * @param {HostUpdateParams} body The properties to update.
     * @param {string} infraEnvId The infra-env ID of the host to be updated.
     * @param {string} hostId The host that should be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2UpdateHost: async (
      body: HostUpdateParams,
      infraEnvId: string,
      hostId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling v2UpdateHost.',
        );
      }
      // verify required parameter 'infraEnvId' is not null or undefined
      if (infraEnvId === null || infraEnvId === undefined) {
        throw new RequiredError(
          'infraEnvId',
          'Required parameter infraEnvId was null or undefined when calling v2UpdateHost.',
        );
      }
      // verify required parameter 'hostId' is not null or undefined
      if (hostId === null || hostId === undefined) {
        throw new RequiredError(
          'hostId',
          'Required parameter hostId was null or undefined when calling v2UpdateHost.',
        );
      }
      const localVarPath = `/v2/infra-envs/{infra_env_id}/hosts/{host_id}`
        .replace(`{${'infra_env_id'}}`, encodeURIComponent(String(infraEnvId)))
        .replace(`{${'host_id'}}`, encodeURIComponent(String(hostId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Patch the ignition file for this host
     * @param {HostIgnitionParams} body Ignition config overrides.
     * @param {string} infraEnvId The infra-env of the host whose ignition file should be updated.
     * @param {string} hostId The host whose ignition file should be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2UpdateHostIgnition: async (
      body: HostIgnitionParams,
      infraEnvId: string,
      hostId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling v2UpdateHostIgnition.',
        );
      }
      // verify required parameter 'infraEnvId' is not null or undefined
      if (infraEnvId === null || infraEnvId === undefined) {
        throw new RequiredError(
          'infraEnvId',
          'Required parameter infraEnvId was null or undefined when calling v2UpdateHostIgnition.',
        );
      }
      // verify required parameter 'hostId' is not null or undefined
      if (hostId === null || hostId === undefined) {
        throw new RequiredError(
          'hostId',
          'Required parameter hostId was null or undefined when calling v2UpdateHostIgnition.',
        );
      }
      const localVarPath = `/v2/infra-envs/{infra_env_id}/hosts/{host_id}/ignition`
        .replace(`{${'infra_env_id'}}`, encodeURIComponent(String(infraEnvId)))
        .replace(`{${'host_id'}}`, encodeURIComponent(String(hostId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Update installation progress.
     * @param {HostProgress} body New progress value.
     * @param {string} infraEnvId The infra-env of the host being updated.
     * @param {string} hostId The ID of the host to update.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is updating progress.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2UpdateHostInstallProgress: async (
      body: HostProgress,
      infraEnvId: string,
      hostId: string,
      discoveryAgentVersion?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling v2UpdateHostInstallProgress.',
        );
      }
      // verify required parameter 'infraEnvId' is not null or undefined
      if (infraEnvId === null || infraEnvId === undefined) {
        throw new RequiredError(
          'infraEnvId',
          'Required parameter infraEnvId was null or undefined when calling v2UpdateHostInstallProgress.',
        );
      }
      // verify required parameter 'hostId' is not null or undefined
      if (hostId === null || hostId === undefined) {
        throw new RequiredError(
          'hostId',
          'Required parameter hostId was null or undefined when calling v2UpdateHostInstallProgress.',
        );
      }
      const localVarPath = `/v2/infra-envs/{infra_env_id}/hosts/{host_id}/progress`
        .replace(`{${'infra_env_id'}}`, encodeURIComponent(String(infraEnvId)))
        .replace(`{${'host_id'}}`, encodeURIComponent(String(hostId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication agentAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Secret-Key')
            : await configuration.apiKey;
        localVarHeaderParameter['X-Secret-Key'] = localVarApiKeyValue;
      }

      if (discoveryAgentVersion !== undefined && discoveryAgentVersion !== null) {
        localVarHeaderParameter['discovery_agent_version'] = String(discoveryAgentVersion);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Updates a host's installer arguments.
     * @param {InstallerArgsParams} body The updated installer arguments.
     * @param {string} infraEnvId The infra-env of the host whose installer arguments should be updated.
     * @param {string} hostId The host whose installer arguments should be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2UpdateHostInstallerArgs: async (
      body: InstallerArgsParams,
      infraEnvId: string,
      hostId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling v2UpdateHostInstallerArgs.',
        );
      }
      // verify required parameter 'infraEnvId' is not null or undefined
      if (infraEnvId === null || infraEnvId === undefined) {
        throw new RequiredError(
          'infraEnvId',
          'Required parameter infraEnvId was null or undefined when calling v2UpdateHostInstallerArgs.',
        );
      }
      // verify required parameter 'hostId' is not null or undefined
      if (hostId === null || hostId === undefined) {
        throw new RequiredError(
          'hostId',
          'Required parameter hostId was null or undefined when calling v2UpdateHostInstallerArgs.',
        );
      }
      const localVarPath = `/v2/infra-envs/{infra_env_id}/hosts/{host_id}/installer-args`
        .replace(`{${'infra_env_id'}}`, encodeURIComponent(String(infraEnvId)))
        .replace(`{${'host_id'}}`, encodeURIComponent(String(hostId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'PATCH',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication userAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('Authorization')
            : await configuration.apiKey;
        localVarHeaderParameter['Authorization'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Update log collection state and progress.
     * @param {LogsProgressParams} body Parameters for updating log progress.
     * @param {string} infraEnvId The infra-env whose log progress is being updated.
     * @param {string} hostId The host whose log progress is being updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2UpdateHostLogsProgress: async (
      body: LogsProgressParams,
      infraEnvId: string,
      hostId: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling v2UpdateHostLogsProgress.',
        );
      }
      // verify required parameter 'infraEnvId' is not null or undefined
      if (infraEnvId === null || infraEnvId === undefined) {
        throw new RequiredError(
          'infraEnvId',
          'Required parameter infraEnvId was null or undefined when calling v2UpdateHostLogsProgress.',
        );
      }
      // verify required parameter 'hostId' is not null or undefined
      if (hostId === null || hostId === undefined) {
        throw new RequiredError(
          'hostId',
          'Required parameter hostId was null or undefined when calling v2UpdateHostLogsProgress.',
        );
      }
      const localVarPath = `/v2/infra-envs/{infra_env_id}/hosts/{host_id}/logs-progress`
        .replace(`{${'infra_env_id'}}`, encodeURIComponent(String(infraEnvId)))
        .replace(`{${'host_id'}}`, encodeURIComponent(String(hostId)));
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'PUT',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication agentAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Secret-Key')
            : await configuration.apiKey;
        localVarHeaderParameter['X-Secret-Key'] = localVarApiKeyValue;
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Transfer the ingress certificate for the cluster.
     * @param {string} body The ingress certificate.
     * @param {string} clusterId The cluster to associate with the ingress certificate.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is uploading the ingress certificate.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2UploadClusterIngressCert: async (
      body: string,
      clusterId: string,
      discoveryAgentVersion?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'body' is not null or undefined
      if (body === null || body === undefined) {
        throw new RequiredError(
          'body',
          'Required parameter body was null or undefined when calling v2UploadClusterIngressCert.',
        );
      }
      // verify required parameter 'clusterId' is not null or undefined
      if (clusterId === null || clusterId === undefined) {
        throw new RequiredError(
          'clusterId',
          'Required parameter clusterId was null or undefined when calling v2UploadClusterIngressCert.',
        );
      }
      const localVarPath = `/v2/clusters/{cluster_id}/uploads/ingress-cert`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication agentAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Secret-Key')
            : await configuration.apiKey;
        localVarHeaderParameter['X-Secret-Key'] = localVarApiKeyValue;
      }

      if (discoveryAgentVersion !== undefined && discoveryAgentVersion !== null) {
        localVarHeaderParameter['discovery_agent_version'] = String(discoveryAgentVersion);
      }

      localVarHeaderParameter['Content-Type'] = 'application/json';

      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      const needsSerialization =
        typeof body !== 'string' ||
        localVarRequestOptions.headers['Content-Type'] === 'application/json';
      localVarRequestOptions.data = needsSerialization
        ? JSON.stringify(body !== undefined ? body : {})
        : body || '';

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
    /**
     * Agent API to upload logs.
     * @param {string} logsType The type of log file to be uploaded.
     * @param {string} clusterId The cluster whose logs should be uploaded.
     * @param {Blob} [upfile]
     * @param {string} [infraEnvId] The infra-env ID of the host.
     * @param {string} [hostId] The host whose logs should be uploaded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    v2UploadLogsForm: async (
      logsType: string,
      clusterId: string,
      upfile?: Blob,
      infraEnvId?: string,
      hostId?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      // verify required parameter 'logsType' is not null or undefined
      if (logsType === null || logsType === undefined) {
        throw new RequiredError(
          'logsType',
          'Required parameter logsType was null or undefined when calling v2UploadLogsForm.',
        );
      }
      // verify required parameter 'clusterId' is not null or undefined
      if (clusterId === null || clusterId === undefined) {
        throw new RequiredError(
          'clusterId',
          'Required parameter clusterId was null or undefined when calling v2UploadLogsForm.',
        );
      }
      const localVarPath = `/v2/clusters/{cluster_id}/logs`.replace(
        `{${'cluster_id'}}`,
        encodeURIComponent(String(clusterId)),
      );
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, 'https://example.com');
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions: AxiosRequestConfig = {
        method: 'POST',
        ...baseOptions,
        ...options,
      };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;
      const localVarFormParams = new FormData();

      // authentication agentAuth required
      if (configuration && configuration.apiKey) {
        const localVarApiKeyValue =
          typeof configuration.apiKey === 'function'
            ? await configuration.apiKey('X-Secret-Key')
            : await configuration.apiKey;
        localVarHeaderParameter['X-Secret-Key'] = localVarApiKeyValue;
      }

      if (logsType !== undefined) {
        localVarQueryParameter['logs_type'] = logsType;
      }

      if (infraEnvId !== undefined) {
        localVarQueryParameter['infra_env_id'] = infraEnvId;
      }

      if (hostId !== undefined) {
        localVarQueryParameter['host_id'] = hostId;
      }

      if (upfile !== undefined) {
        localVarFormParams.append('upfile', upfile as any);
      }

      localVarHeaderParameter['Content-Type'] = 'multipart/form-data';
      const query = new URLSearchParams(localVarUrlObj.search);
      for (const key in localVarQueryParameter) {
        query.set(key, localVarQueryParameter[key]);
      }
      for (const key in options.params) {
        query.set(key, options.params[key]);
      }
      localVarUrlObj.search = new URLSearchParams(query).toString();
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = {
        ...localVarHeaderParameter,
        ...headersFromBaseOptions,
        ...options.headers,
      };
      localVarRequestOptions.data = localVarFormParams;

      return {
        url: localVarUrlObj.pathname + localVarUrlObj.search + localVarUrlObj.hash,
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * InstallerApi - functional programming interface
 * @export
 */
export const InstallerApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Bind host to a cluster
     * @param {BindHostParams} body The parameters for the host binding.
     * @param {string} infraEnvId The infra-env of the host that is being bound.
     * @param {string} hostId The host that is being bound.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bindHost(
      body: BindHostParams,
      infraEnvId: string,
      hostId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Host>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(configuration).bindHost(
        body,
        infraEnvId,
        hostId,
        options,
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Deletes an infra-env.
     * @param {string} infraEnvId The infra-env to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deregisterInfraEnv(
      infraEnvId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).deregisterInfraEnv(infraEnvId, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get the initial ramdisk for minimal ISO based installations.
     * @param {string} infraEnvId The infra-env of the host that should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async downloadMinimalInitrd(
      infraEnvId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Blob>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).downloadMinimalInitrd(infraEnvId, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * A list of platforms that this cluster can support in its current configuration.
     * @param {string} clusterId The cluster whose platform types should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getClusterSupportedPlatforms(
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Array<PlatformType>>>
    > {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).getClusterSupportedPlatforms(clusterId, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieves the details of the infra-env.
     * @param {string} infraEnvId The infra-env to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInfraEnv(
      infraEnvId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InfraEnv>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(configuration).getInfraEnv(
        infraEnvId,
        options,
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Creates a new pre-signed image download URL for the infra-env.
     * @param {string} infraEnvId The infra-env to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInfraEnvDownloadURL(
      infraEnvId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<PresignedUrl>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).getInfraEnvDownloadURL(infraEnvId, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Creates a new pre-signed download URL for the infra-env.
     * @param {string} infraEnvId The file&#x27;s infra-env.
     * @param {string} fileName The file to be downloaded.
     * @param {string} [ipxeScriptType] Specify the script type to be served for iPXE.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInfraEnvPresignedFileURL(
      infraEnvId: string,
      fileName: string,
      ipxeScriptType?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<PresignedUrl>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).getInfraEnvPresignedFileURL(infraEnvId, fileName, ipxeScriptType, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieves the architecture support-levels for each OpenShift version.
     * @param {string} openshiftVersion Version of the OpenShift cluster.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSupportedArchitectures(
      openshiftVersion: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse2001>>
    > {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).getSupportedArchitectures(openshiftVersion, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieves the features support levels for each OpenShift version.
     * @param {string} openshiftVersion Version of the OpenShift cluster.
     * @param {string} [cpuArchitecture] The CPU architecture of the image (x86_64/arm64/etc).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSupportedFeatures(
      openshiftVersion: string,
      cpuArchitecture?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InlineResponse200>>
    > {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).getSupportedFeatures(openshiftVersion, cpuArchitecture, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get a list of cluster hosts according to supplied filters.
     * @param {string} clusterId The cluster whose hosts should be retrieved.
     * @param {string} [role] Role to request.
     * @param {string} [status] Hosts status to request.
     * @param {boolean} [withInventory] If true return the host&#x27;s inventory.
     * @param {boolean} [withConnectivity] If true return the host&#x27;s connectivity.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listClusterHosts(
      clusterId: string,
      role?: string,
      status?: string,
      withInventory?: boolean,
      withConnectivity?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<HostList>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(configuration).listClusterHosts(
        clusterId,
        role,
        status,
        withInventory,
        withConnectivity,
        options,
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieves the list of infra-envs.
     * @param {string} [clusterId] If provided, returns only infra-envs which directly reference this cluster.
     * @param {string} [owner] If provided, returns only infra-envs that are owned by the specified user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listInfraEnvs(
      clusterId?: string,
      owner?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InfraEnvList>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(configuration).listInfraEnvs(
        clusterId,
        owner,
        options,
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Regenerate InfraEnv token signing key.
     * @param {string} infraEnvId The target InfraEnv.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async regenerateInfraEnvSigningKey(
      infraEnvId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).regenerateInfraEnvSigningKey(infraEnvId, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Creates a new OpenShift Discovery ISO.
     * @param {InfraEnvCreateParams} body The parameters for the generated ISO.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async registerInfraEnv(
      body: InfraEnvCreateParams,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InfraEnv>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(configuration).registerInfraEnv(
        body,
        options,
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Transforms installed cluster to a state which allows adding hosts.
     * @param {string} clusterId The cluster to transform.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async transformClusterToAddingHosts(
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Cluster>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).transformClusterToAddingHosts(clusterId, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Deprecated, maintained for legacy purposes. Does the same thing as allow-add-hosts. Use allow-add-hosts instead.
     * @param {string} clusterId The cluster to transform.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async transformClusterToDay2(
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Cluster>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).transformClusterToDay2(clusterId, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Unbind host to a cluster
     * @param {string} infraEnvId The infra-env of the host that is being bound.
     * @param {string} hostId The host that is being bound.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unbindHost(
      infraEnvId: string,
      hostId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Host>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(configuration).unbindHost(
        infraEnvId,
        hostId,
        options,
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Updates an infra-env.
     * @param {InfraEnvUpdateParams} body The properties to update.
     * @param {string} infraEnvId The infra-env to be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateInfraEnv(
      body: InfraEnvUpdateParams,
      infraEnvId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<InfraEnv>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(configuration).updateInfraEnv(
        body,
        infraEnvId,
        options,
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Cancels an ongoing installation.
     * @param {string} clusterId The cluster whose installation is to be canceled.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2CancelInstallation(
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Cluster>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).v2CancelInstallation(clusterId, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Agent API to mark a finalizing installation as complete and progress to 100%.
     * @param {CompletionParams} body The final status of the cluster installation.
     * @param {string} clusterId The cluster whose installation is being completing.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is completing the installation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2CompleteInstallation(
      body: CompletionParams,
      clusterId: string,
      discoveryAgentVersion?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Cluster>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).v2CompleteInstallation(body, clusterId, discoveryAgentVersion, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Deletes an OpenShift cluster definition.
     * @param {string} clusterId The cluster to be deregistered.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2DeregisterCluster(
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).v2DeregisterCluster(clusterId, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Deregisters an OpenShift host.
     * @param {string} infraEnvId The infra-env of the host that should be deregistered.
     * @param {string} hostId The host that should be deregistered.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2DeregisterHost(
      infraEnvId: string,
      hostId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(configuration).v2DeregisterHost(
        infraEnvId,
        hostId,
        options,
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Downloads credentials relating to the installed/installing cluster.
     * @param {string} clusterId The cluster that owns the credential file that should be downloaded.
     * @param {string} fileName The credential file to be downloaded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2DownloadClusterCredentials(
      clusterId: string,
      fileName: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Blob>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).v2DownloadClusterCredentials(clusterId, fileName, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Downloads files relating to the installed/installing cluster.
     * @param {string} clusterId The cluster that owns the file that should be downloaded.
     * @param {string} fileName The file to be downloaded.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is downloading the file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2DownloadClusterFiles(
      clusterId: string,
      fileName: string,
      discoveryAgentVersion?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Blob>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).v2DownloadClusterFiles(clusterId, fileName, discoveryAgentVersion, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Download cluster logs.
     * @param {string} clusterId The cluster whose logs should be downloaded.
     * @param {string} [logsType] The type of logs to be downloaded.
     * @param {string} [hostId] A specific host in the cluster whose logs should be downloaded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2DownloadClusterLogs(
      clusterId: string,
      logsType?: string,
      hostId?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Blob>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).v2DownloadClusterLogs(clusterId, logsType, hostId, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Downloads the customized ignition file for this bound host, produces octet stream. For unbound host - error is returned
     * @param {string} infraEnvId The infra-env of the host whose ignition file should be downloaded.
     * @param {string} hostId The host whose ignition file should be downloaded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2DownloadHostIgnition(
      infraEnvId: string,
      hostId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Blob>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).v2DownloadHostIgnition(infraEnvId, hostId, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Downloads the customized ignition file for this host
     * @param {string} infraEnvId The infra-env whose file should be downloaded.
     * @param {string} fileName The file to be downloaded.
     * @param {string} [mac] Mac address of the host running ipxe script.
     * @param {string} [ipxeScriptType] Specify the script type to be served for iPXE.
     * @param {string} [discoveryIsoType] Overrides the ISO type for the disovery ignition, either &#x27;full-iso&#x27; or &#x27;minimal-iso&#x27;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2DownloadInfraEnvFiles(
      infraEnvId: string,
      fileName: string,
      mac?: string,
      ipxeScriptType?: string,
      discoveryIsoType?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Blob>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).v2DownloadInfraEnvFiles(
        infraEnvId,
        fileName,
        mac,
        ipxeScriptType,
        discoveryIsoType,
        options,
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieves the details of the OpenShift cluster.
     * @param {string} clusterId The cluster to be retrieved.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is retrieving the cluster details.
     * @param {boolean} [getUnregisteredClusters] Whether to return clusters that have been unregistered.
     * @param {boolean} [excludeHosts] If true, do not include hosts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2GetCluster(
      clusterId: string,
      discoveryAgentVersion?: string,
      getUnregisteredClusters?: boolean,
      excludeHosts?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Cluster>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(configuration).v2GetCluster(
        clusterId,
        discoveryAgentVersion,
        getUnregisteredClusters,
        excludeHosts,
        options,
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get the default values for various cluster properties.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2GetClusterDefaultConfig(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ClusterDefaultConfig>>
    > {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).v2GetClusterDefaultConfig(options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get the cluster's install config YAML.
     * @param {string} clusterId The cluster whose install config is being retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2GetClusterInstallConfig(
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<string>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).v2GetClusterInstallConfig(clusterId, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get the cluster admin credentials.
     * @param {string} clusterId The cluster whose admin credentials should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2GetCredentials(
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Credentials>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(configuration).v2GetCredentials(
        clusterId,
        options,
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieves the details of the OpenShift host.
     * @param {string} infraEnvId The infra-env of the host that should be retrieved.
     * @param {string} hostId The host that should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2GetHost(
      infraEnvId: string,
      hostId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Host>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(configuration).v2GetHost(
        infraEnvId,
        hostId,
        options,
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Fetch the ignition file for this host as a string. In case of unbound host produces an error
     * @param {string} infraEnvId The infra-env of the host whose ignition file should be obtained.
     * @param {string} hostId The host whose ignition file should be obtained.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2GetHostIgnition(
      infraEnvId: string,
      hostId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<HostIgnitionParams>>
    > {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).v2GetHostIgnition(infraEnvId, hostId, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Fetch the validations which are to be ignored for this cluster.
     * @param {string} clusterId The cluster whose failing validations should be ignored according to this list.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2GetIgnoredValidations(
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<IgnoredValidations>>
    > {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).v2GetIgnoredValidations(clusterId, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieves the next operations that the host agent needs to perform.
     * @param {string} infraEnvId The infra-env of the host that is retrieving instructions.
     * @param {string} hostId The host that is retrieving instructions.
     * @param {number} [timestamp] The time on the host as seconds since the Unix epoch.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is retrieving instructions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2GetNextSteps(
      infraEnvId: string,
      hostId: string,
      timestamp?: number,
      discoveryAgentVersion?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Steps>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(configuration).v2GetNextSteps(
        infraEnvId,
        hostId,
        timestamp,
        discoveryAgentVersion,
        options,
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get preflight requirements for a cluster.
     * @param {string} clusterId The cluster to return preflight requirements for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2GetPreflightRequirements(
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (
        axios?: AxiosInstance,
        basePath?: string,
      ) => Promise<AxiosResponse<PreflightHardwareRequirements>>
    > {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).v2GetPreflightRequirements(clusterId, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Get the cluster admin credentials.
     * @param {string} clusterId The cluster that owns the file that should be downloaded.
     * @param {string} fileName The file to be downloaded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2GetPresignedForClusterCredentials(
      clusterId: string,
      fileName: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<PresignedUrl>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).v2GetPresignedForClusterCredentials(clusterId, fileName, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieves a pre-signed S3 URL for downloading cluster files.
     * @param {string} clusterId The cluster that owns the file that should be downloaded.
     * @param {string} fileName The file to be downloaded.
     * @param {string} [logsType] If downloading logs, the type of logs to download.
     * @param {string} [hostId] If downloading a file related to a host, the relevant host.
     * @param {string} [additionalName] If downloading a manifest, the file name, prefaced with folder name, for example, openshift/99-openshift-xyz.yaml.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2GetPresignedForClusterFiles(
      clusterId: string,
      fileName: string,
      logsType?: string,
      hostId?: string,
      additionalName?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<PresignedUrl>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).v2GetPresignedForClusterFiles(
        clusterId,
        fileName,
        logsType,
        hostId,
        additionalName,
        options,
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Import an AI cluster using minimal data associated with existing OCP cluster, in order to allow adding day2 hosts to that cluster
     * @param {ImportClusterParams} body Parameters for importing a OCP cluster for adding nodes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2ImportCluster(
      body: ImportClusterParams,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Cluster>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(configuration).v2ImportCluster(
        body,
        options,
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Installs the OpenShift cluster.
     * @param {string} clusterId The cluster to be installed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2InstallCluster(
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Cluster>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(configuration).v2InstallCluster(
        clusterId,
        options,
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * install specific host for day2 cluster.
     * @param {string} infraEnvId The infra-env of the host that is being installed.
     * @param {string} hostId The host that is being installed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2InstallHost(
      infraEnvId: string,
      hostId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Host>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(configuration).v2InstallHost(
        infraEnvId,
        hostId,
        options,
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieves the list of OpenShift clusters.
     * @param {boolean} [getUnregisteredClusters] Whether to return clusters that have been unregistered.
     * @param {string} [openshiftClusterId] A specific cluster to retrieve.
     * @param {Array<string>} [amsSubscriptionIds] If non-empty, returned Clusters are filtered to those with matching subscription IDs.
     * @param {boolean} [withHosts] Include hosts in the returned list.
     * @param {string} [owner] If provided, returns only clusters that are owned by the specified user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2ListClusters(
      getUnregisteredClusters?: boolean,
      openshiftClusterId?: string,
      amsSubscriptionIds?: Array<string>,
      withHosts?: boolean,
      owner?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<ClusterList>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(configuration).v2ListClusters(
        getUnregisteredClusters,
        openshiftClusterId,
        amsSubscriptionIds,
        withHosts,
        owner,
        options,
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * (DEPRECATED) Retrieves the support levels for features for each OpenShift version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2ListFeatureSupportLevels(
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<FeatureSupportLevels>>
    > {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).v2ListFeatureSupportLevels(options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Retrieves the list of OpenShift hosts that belong the infra-env.
     * @param {string} infraEnvId The infra-env that the hosts are asociated with.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2ListHosts(
      infraEnvId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<HostList>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(configuration).v2ListHosts(
        infraEnvId,
        options,
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Lists operators to be monitored for a cluster.
     * @param {string} clusterId The cluster to return operators for.
     * @param {string} [operatorName] An operator in the specified cluster to return its data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2ListOfClusterOperators(
      clusterId: string,
      operatorName?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<MonitoredOperatorsList>>
    > {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).v2ListOfClusterOperators(clusterId, operatorName, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Posts the result of the operations from the host agent.
     * @param {string} infraEnvId The infra-env of the host that is posting results.
     * @param {string} hostId The host that is posting results.
     * @param {StepReply} [body] The results to be posted.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is posting results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2PostStepReply(
      infraEnvId: string,
      hostId: string,
      body?: StepReply,
      discoveryAgentVersion?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(configuration).v2PostStepReply(
        infraEnvId,
        hostId,
        body,
        discoveryAgentVersion,
        options,
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Creates a new OpenShift cluster definition.
     * @param {ClusterCreateParams} body The properties describing the new cluster.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2RegisterCluster(
      body: ClusterCreateParams,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Cluster>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).v2RegisterCluster(body, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Registers a new OpenShift agent.
     * @param {HostCreateParams} body The description of the agent being registered.
     * @param {string} infraEnvId The infra-env that the agent is associated with.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is registering the agent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2RegisterHost(
      body: HostCreateParams,
      infraEnvId: string,
      discoveryAgentVersion?: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<HostRegistrationResponse>>
    > {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(configuration).v2RegisterHost(
        body,
        infraEnvId,
        discoveryAgentVersion,
        options,
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Controller API to report of monitored operators.
     * @param {OperatorMonitorReport} body The operators monitor report.
     * @param {string} clusterId The cluster whose operators are being monitored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2ReportMonitoredOperatorStatus(
      body: OperatorMonitorReport,
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).v2ReportMonitoredOperatorStatus(body, clusterId, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Resets a failed installation.
     * @param {string} clusterId The cluster whose installation is to be reset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2ResetCluster(
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Cluster>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(configuration).v2ResetCluster(
        clusterId,
        options,
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * reset a failed host for day2 cluster.
     * @param {string} infraEnvId The infra-env of the host that is being reset.
     * @param {string} hostId The host that is being reset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2ResetHost(
      infraEnvId: string,
      hostId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Host>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(configuration).v2ResetHost(
        infraEnvId,
        hostId,
        options,
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Reset failed host validation. It may be performed on any host validation with persistent validation result.
     * @summary Reset failed host validation.
     * @param {string} infraEnvId The infra-env of the host that its validation is being reset.
     * @param {string} hostId The host that its validation is being reset.
     * @param {string} validationId The id of the validation being reset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2ResetHostValidation(
      infraEnvId: string,
      hostId: string,
      validationId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Host>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).v2ResetHostValidation(infraEnvId, hostId, validationId, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Register the validations which are to be ignored for this cluster.
     * @param {IgnoredValidations} body The validations to be ignored.
     * @param {string} clusterId The cluster whose failing validations should be ignored according to this list.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2SetIgnoredValidations(
      body: IgnoredValidations,
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<
      (axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<IgnoredValidations>>
    > {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).v2SetIgnoredValidations(body, clusterId, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Updates an OpenShift cluster definition.
     * @param {V2ClusterUpdateParams} body The properties to update.
     * @param {string} clusterId The cluster to be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2UpdateCluster(
      body: V2ClusterUpdateParams,
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Cluster>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(configuration).v2UpdateCluster(
        body,
        clusterId,
        options,
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Override values in the install config.
     * @param {string} body Install config overrides.
     * @param {string} clusterId The cluster whose install config is being updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2UpdateClusterInstallConfig(
      body: string,
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).v2UpdateClusterInstallConfig(body, clusterId, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Update log collection state and progress.
     * @param {LogsProgressParams} body Parameters for updating log progress.
     * @param {string} clusterId The cluster whose log progress is being updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2UpdateClusterLogsProgress(
      body: LogsProgressParams,
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).v2UpdateClusterLogsProgress(body, clusterId, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Update an Openshift host
     * @param {HostUpdateParams} body The properties to update.
     * @param {string} infraEnvId The infra-env ID of the host to be updated.
     * @param {string} hostId The host that should be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2UpdateHost(
      body: HostUpdateParams,
      infraEnvId: string,
      hostId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Host>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(configuration).v2UpdateHost(
        body,
        infraEnvId,
        hostId,
        options,
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Patch the ignition file for this host
     * @param {HostIgnitionParams} body Ignition config overrides.
     * @param {string} infraEnvId The infra-env of the host whose ignition file should be updated.
     * @param {string} hostId The host whose ignition file should be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2UpdateHostIgnition(
      body: HostIgnitionParams,
      infraEnvId: string,
      hostId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).v2UpdateHostIgnition(body, infraEnvId, hostId, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Update installation progress.
     * @param {HostProgress} body New progress value.
     * @param {string} infraEnvId The infra-env of the host being updated.
     * @param {string} hostId The ID of the host to update.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is updating progress.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2UpdateHostInstallProgress(
      body: HostProgress,
      infraEnvId: string,
      hostId: string,
      discoveryAgentVersion?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).v2UpdateHostInstallProgress(body, infraEnvId, hostId, discoveryAgentVersion, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Updates a host's installer arguments.
     * @param {InstallerArgsParams} body The updated installer arguments.
     * @param {string} infraEnvId The infra-env of the host whose installer arguments should be updated.
     * @param {string} hostId The host whose installer arguments should be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2UpdateHostInstallerArgs(
      body: InstallerArgsParams,
      infraEnvId: string,
      hostId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<Host>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).v2UpdateHostInstallerArgs(body, infraEnvId, hostId, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Update log collection state and progress.
     * @param {LogsProgressParams} body Parameters for updating log progress.
     * @param {string} infraEnvId The infra-env whose log progress is being updated.
     * @param {string} hostId The host whose log progress is being updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2UpdateHostLogsProgress(
      body: LogsProgressParams,
      infraEnvId: string,
      hostId: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).v2UpdateHostLogsProgress(body, infraEnvId, hostId, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Transfer the ingress certificate for the cluster.
     * @param {string} body The ingress certificate.
     * @param {string} clusterId The cluster to associate with the ingress certificate.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is uploading the ingress certificate.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2UploadClusterIngressCert(
      body: string,
      clusterId: string,
      discoveryAgentVersion?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(
        configuration,
      ).v2UploadClusterIngressCert(body, clusterId, discoveryAgentVersion, options);
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Agent API to upload logs.
     * @param {string} logsType The type of log file to be uploaded.
     * @param {string} clusterId The cluster whose logs should be uploaded.
     * @param {Blob} [upfile]
     * @param {string} [infraEnvId] The infra-env ID of the host.
     * @param {string} [hostId] The host whose logs should be uploaded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2UploadLogsForm(
      logsType: string,
      clusterId: string,
      upfile?: Blob,
      infraEnvId?: string,
      hostId?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => Promise<AxiosResponse<void>>> {
      const localVarAxiosArgs = await InstallerApiAxiosParamCreator(configuration).v2UploadLogsForm(
        logsType,
        clusterId,
        upfile,
        infraEnvId,
        hostId,
        options,
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs: AxiosRequestConfig = {
          ...localVarAxiosArgs.options,
          url: basePath + localVarAxiosArgs.url,
        };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * InstallerApi - factory interface
 * @export
 */
export const InstallerApiFactory = function (
  configuration?: Configuration,
  basePath?: string,
  axios?: AxiosInstance,
) {
  return {
    /**
     * Bind host to a cluster
     * @param {BindHostParams} body The parameters for the host binding.
     * @param {string} infraEnvId The infra-env of the host that is being bound.
     * @param {string} hostId The host that is being bound.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async bindHost(
      body: BindHostParams,
      infraEnvId: string,
      hostId: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Host>> {
      return InstallerApiFp(configuration)
        .bindHost(body, infraEnvId, hostId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes an infra-env.
     * @param {string} infraEnvId The infra-env to be deleted.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async deregisterInfraEnv(
      infraEnvId: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<void>> {
      return InstallerApiFp(configuration)
        .deregisterInfraEnv(infraEnvId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get the initial ramdisk for minimal ISO based installations.
     * @param {string} infraEnvId The infra-env of the host that should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async downloadMinimalInitrd(
      infraEnvId: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Blob>> {
      return InstallerApiFp(configuration)
        .downloadMinimalInitrd(infraEnvId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * A list of platforms that this cluster can support in its current configuration.
     * @param {string} clusterId The cluster whose platform types should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getClusterSupportedPlatforms(
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Array<PlatformType>>> {
      return InstallerApiFp(configuration)
        .getClusterSupportedPlatforms(clusterId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves the details of the infra-env.
     * @param {string} infraEnvId The infra-env to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInfraEnv(
      infraEnvId: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<InfraEnv>> {
      return InstallerApiFp(configuration)
        .getInfraEnv(infraEnvId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates a new pre-signed image download URL for the infra-env.
     * @param {string} infraEnvId The infra-env to be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInfraEnvDownloadURL(
      infraEnvId: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<PresignedUrl>> {
      return InstallerApiFp(configuration)
        .getInfraEnvDownloadURL(infraEnvId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates a new pre-signed download URL for the infra-env.
     * @param {string} infraEnvId The file&#x27;s infra-env.
     * @param {string} fileName The file to be downloaded.
     * @param {string} [ipxeScriptType] Specify the script type to be served for iPXE.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getInfraEnvPresignedFileURL(
      infraEnvId: string,
      fileName: string,
      ipxeScriptType?: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<PresignedUrl>> {
      return InstallerApiFp(configuration)
        .getInfraEnvPresignedFileURL(infraEnvId, fileName, ipxeScriptType, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves the architecture support-levels for each OpenShift version.
     * @param {string} openshiftVersion Version of the OpenShift cluster.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSupportedArchitectures(
      openshiftVersion: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<InlineResponse2001>> {
      return InstallerApiFp(configuration)
        .getSupportedArchitectures(openshiftVersion, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves the features support levels for each OpenShift version.
     * @param {string} openshiftVersion Version of the OpenShift cluster.
     * @param {string} [cpuArchitecture] The CPU architecture of the image (x86_64/arm64/etc).
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getSupportedFeatures(
      openshiftVersion: string,
      cpuArchitecture?: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<InlineResponse200>> {
      return InstallerApiFp(configuration)
        .getSupportedFeatures(openshiftVersion, cpuArchitecture, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get a list of cluster hosts according to supplied filters.
     * @param {string} clusterId The cluster whose hosts should be retrieved.
     * @param {string} [role] Role to request.
     * @param {string} [status] Hosts status to request.
     * @param {boolean} [withInventory] If true return the host&#x27;s inventory.
     * @param {boolean} [withConnectivity] If true return the host&#x27;s connectivity.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listClusterHosts(
      clusterId: string,
      role?: string,
      status?: string,
      withInventory?: boolean,
      withConnectivity?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<HostList>> {
      return InstallerApiFp(configuration)
        .listClusterHosts(clusterId, role, status, withInventory, withConnectivity, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves the list of infra-envs.
     * @param {string} [clusterId] If provided, returns only infra-envs which directly reference this cluster.
     * @param {string} [owner] If provided, returns only infra-envs that are owned by the specified user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async listInfraEnvs(
      clusterId?: string,
      owner?: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<InfraEnvList>> {
      return InstallerApiFp(configuration)
        .listInfraEnvs(clusterId, owner, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Regenerate InfraEnv token signing key.
     * @param {string} infraEnvId The target InfraEnv.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async regenerateInfraEnvSigningKey(
      infraEnvId: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<void>> {
      return InstallerApiFp(configuration)
        .regenerateInfraEnvSigningKey(infraEnvId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates a new OpenShift Discovery ISO.
     * @param {InfraEnvCreateParams} body The parameters for the generated ISO.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async registerInfraEnv(
      body: InfraEnvCreateParams,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<InfraEnv>> {
      return InstallerApiFp(configuration)
        .registerInfraEnv(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Transforms installed cluster to a state which allows adding hosts.
     * @param {string} clusterId The cluster to transform.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async transformClusterToAddingHosts(
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Cluster>> {
      return InstallerApiFp(configuration)
        .transformClusterToAddingHosts(clusterId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deprecated, maintained for legacy purposes. Does the same thing as allow-add-hosts. Use allow-add-hosts instead.
     * @param {string} clusterId The cluster to transform.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async transformClusterToDay2(
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Cluster>> {
      return InstallerApiFp(configuration)
        .transformClusterToDay2(clusterId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Unbind host to a cluster
     * @param {string} infraEnvId The infra-env of the host that is being bound.
     * @param {string} hostId The host that is being bound.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async unbindHost(
      infraEnvId: string,
      hostId: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Host>> {
      return InstallerApiFp(configuration)
        .unbindHost(infraEnvId, hostId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Updates an infra-env.
     * @param {InfraEnvUpdateParams} body The properties to update.
     * @param {string} infraEnvId The infra-env to be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async updateInfraEnv(
      body: InfraEnvUpdateParams,
      infraEnvId: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<InfraEnv>> {
      return InstallerApiFp(configuration)
        .updateInfraEnv(body, infraEnvId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Cancels an ongoing installation.
     * @param {string} clusterId The cluster whose installation is to be canceled.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2CancelInstallation(
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Cluster>> {
      return InstallerApiFp(configuration)
        .v2CancelInstallation(clusterId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Agent API to mark a finalizing installation as complete and progress to 100%.
     * @param {CompletionParams} body The final status of the cluster installation.
     * @param {string} clusterId The cluster whose installation is being completing.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is completing the installation.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2CompleteInstallation(
      body: CompletionParams,
      clusterId: string,
      discoveryAgentVersion?: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Cluster>> {
      return InstallerApiFp(configuration)
        .v2CompleteInstallation(body, clusterId, discoveryAgentVersion, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deletes an OpenShift cluster definition.
     * @param {string} clusterId The cluster to be deregistered.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2DeregisterCluster(
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<void>> {
      return InstallerApiFp(configuration)
        .v2DeregisterCluster(clusterId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Deregisters an OpenShift host.
     * @param {string} infraEnvId The infra-env of the host that should be deregistered.
     * @param {string} hostId The host that should be deregistered.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2DeregisterHost(
      infraEnvId: string,
      hostId: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<void>> {
      return InstallerApiFp(configuration)
        .v2DeregisterHost(infraEnvId, hostId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Downloads credentials relating to the installed/installing cluster.
     * @param {string} clusterId The cluster that owns the credential file that should be downloaded.
     * @param {string} fileName The credential file to be downloaded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2DownloadClusterCredentials(
      clusterId: string,
      fileName: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Blob>> {
      return InstallerApiFp(configuration)
        .v2DownloadClusterCredentials(clusterId, fileName, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Downloads files relating to the installed/installing cluster.
     * @param {string} clusterId The cluster that owns the file that should be downloaded.
     * @param {string} fileName The file to be downloaded.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is downloading the file.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2DownloadClusterFiles(
      clusterId: string,
      fileName: string,
      discoveryAgentVersion?: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Blob>> {
      return InstallerApiFp(configuration)
        .v2DownloadClusterFiles(clusterId, fileName, discoveryAgentVersion, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Download cluster logs.
     * @param {string} clusterId The cluster whose logs should be downloaded.
     * @param {string} [logsType] The type of logs to be downloaded.
     * @param {string} [hostId] A specific host in the cluster whose logs should be downloaded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2DownloadClusterLogs(
      clusterId: string,
      logsType?: string,
      hostId?: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Blob>> {
      return InstallerApiFp(configuration)
        .v2DownloadClusterLogs(clusterId, logsType, hostId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Downloads the customized ignition file for this bound host, produces octet stream. For unbound host - error is returned
     * @param {string} infraEnvId The infra-env of the host whose ignition file should be downloaded.
     * @param {string} hostId The host whose ignition file should be downloaded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2DownloadHostIgnition(
      infraEnvId: string,
      hostId: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Blob>> {
      return InstallerApiFp(configuration)
        .v2DownloadHostIgnition(infraEnvId, hostId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Downloads the customized ignition file for this host
     * @param {string} infraEnvId The infra-env whose file should be downloaded.
     * @param {string} fileName The file to be downloaded.
     * @param {string} [mac] Mac address of the host running ipxe script.
     * @param {string} [ipxeScriptType] Specify the script type to be served for iPXE.
     * @param {string} [discoveryIsoType] Overrides the ISO type for the disovery ignition, either &#x27;full-iso&#x27; or &#x27;minimal-iso&#x27;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2DownloadInfraEnvFiles(
      infraEnvId: string,
      fileName: string,
      mac?: string,
      ipxeScriptType?: string,
      discoveryIsoType?: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Blob>> {
      return InstallerApiFp(configuration)
        .v2DownloadInfraEnvFiles(
          infraEnvId,
          fileName,
          mac,
          ipxeScriptType,
          discoveryIsoType,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves the details of the OpenShift cluster.
     * @param {string} clusterId The cluster to be retrieved.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is retrieving the cluster details.
     * @param {boolean} [getUnregisteredClusters] Whether to return clusters that have been unregistered.
     * @param {boolean} [excludeHosts] If true, do not include hosts.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2GetCluster(
      clusterId: string,
      discoveryAgentVersion?: string,
      getUnregisteredClusters?: boolean,
      excludeHosts?: boolean,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Cluster>> {
      return InstallerApiFp(configuration)
        .v2GetCluster(
          clusterId,
          discoveryAgentVersion,
          getUnregisteredClusters,
          excludeHosts,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Get the default values for various cluster properties.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2GetClusterDefaultConfig(
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<ClusterDefaultConfig>> {
      return InstallerApiFp(configuration)
        .v2GetClusterDefaultConfig(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get the cluster's install config YAML.
     * @param {string} clusterId The cluster whose install config is being retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2GetClusterInstallConfig(
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<string>> {
      return InstallerApiFp(configuration)
        .v2GetClusterInstallConfig(clusterId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get the cluster admin credentials.
     * @param {string} clusterId The cluster whose admin credentials should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2GetCredentials(
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Credentials>> {
      return InstallerApiFp(configuration)
        .v2GetCredentials(clusterId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves the details of the OpenShift host.
     * @param {string} infraEnvId The infra-env of the host that should be retrieved.
     * @param {string} hostId The host that should be retrieved.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2GetHost(
      infraEnvId: string,
      hostId: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Host>> {
      return InstallerApiFp(configuration)
        .v2GetHost(infraEnvId, hostId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Fetch the ignition file for this host as a string. In case of unbound host produces an error
     * @param {string} infraEnvId The infra-env of the host whose ignition file should be obtained.
     * @param {string} hostId The host whose ignition file should be obtained.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2GetHostIgnition(
      infraEnvId: string,
      hostId: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<HostIgnitionParams>> {
      return InstallerApiFp(configuration)
        .v2GetHostIgnition(infraEnvId, hostId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Fetch the validations which are to be ignored for this cluster.
     * @param {string} clusterId The cluster whose failing validations should be ignored according to this list.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2GetIgnoredValidations(
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<IgnoredValidations>> {
      return InstallerApiFp(configuration)
        .v2GetIgnoredValidations(clusterId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves the next operations that the host agent needs to perform.
     * @param {string} infraEnvId The infra-env of the host that is retrieving instructions.
     * @param {string} hostId The host that is retrieving instructions.
     * @param {number} [timestamp] The time on the host as seconds since the Unix epoch.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is retrieving instructions.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2GetNextSteps(
      infraEnvId: string,
      hostId: string,
      timestamp?: number,
      discoveryAgentVersion?: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Steps>> {
      return InstallerApiFp(configuration)
        .v2GetNextSteps(infraEnvId, hostId, timestamp, discoveryAgentVersion, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get preflight requirements for a cluster.
     * @param {string} clusterId The cluster to return preflight requirements for.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2GetPreflightRequirements(
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<PreflightHardwareRequirements>> {
      return InstallerApiFp(configuration)
        .v2GetPreflightRequirements(clusterId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Get the cluster admin credentials.
     * @param {string} clusterId The cluster that owns the file that should be downloaded.
     * @param {string} fileName The file to be downloaded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2GetPresignedForClusterCredentials(
      clusterId: string,
      fileName: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<PresignedUrl>> {
      return InstallerApiFp(configuration)
        .v2GetPresignedForClusterCredentials(clusterId, fileName, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves a pre-signed S3 URL for downloading cluster files.
     * @param {string} clusterId The cluster that owns the file that should be downloaded.
     * @param {string} fileName The file to be downloaded.
     * @param {string} [logsType] If downloading logs, the type of logs to download.
     * @param {string} [hostId] If downloading a file related to a host, the relevant host.
     * @param {string} [additionalName] If downloading a manifest, the file name, prefaced with folder name, for example, openshift/99-openshift-xyz.yaml.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2GetPresignedForClusterFiles(
      clusterId: string,
      fileName: string,
      logsType?: string,
      hostId?: string,
      additionalName?: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<PresignedUrl>> {
      return InstallerApiFp(configuration)
        .v2GetPresignedForClusterFiles(
          clusterId,
          fileName,
          logsType,
          hostId,
          additionalName,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Import an AI cluster using minimal data associated with existing OCP cluster, in order to allow adding day2 hosts to that cluster
     * @param {ImportClusterParams} body Parameters for importing a OCP cluster for adding nodes.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2ImportCluster(
      body: ImportClusterParams,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Cluster>> {
      return InstallerApiFp(configuration)
        .v2ImportCluster(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Installs the OpenShift cluster.
     * @param {string} clusterId The cluster to be installed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2InstallCluster(
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Cluster>> {
      return InstallerApiFp(configuration)
        .v2InstallCluster(clusterId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * install specific host for day2 cluster.
     * @param {string} infraEnvId The infra-env of the host that is being installed.
     * @param {string} hostId The host that is being installed.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2InstallHost(
      infraEnvId: string,
      hostId: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Host>> {
      return InstallerApiFp(configuration)
        .v2InstallHost(infraEnvId, hostId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves the list of OpenShift clusters.
     * @param {boolean} [getUnregisteredClusters] Whether to return clusters that have been unregistered.
     * @param {string} [openshiftClusterId] A specific cluster to retrieve.
     * @param {Array<string>} [amsSubscriptionIds] If non-empty, returned Clusters are filtered to those with matching subscription IDs.
     * @param {boolean} [withHosts] Include hosts in the returned list.
     * @param {string} [owner] If provided, returns only clusters that are owned by the specified user.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2ListClusters(
      getUnregisteredClusters?: boolean,
      openshiftClusterId?: string,
      amsSubscriptionIds?: Array<string>,
      withHosts?: boolean,
      owner?: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<ClusterList>> {
      return InstallerApiFp(configuration)
        .v2ListClusters(
          getUnregisteredClusters,
          openshiftClusterId,
          amsSubscriptionIds,
          withHosts,
          owner,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * (DEPRECATED) Retrieves the support levels for features for each OpenShift version.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2ListFeatureSupportLevels(
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<FeatureSupportLevels>> {
      return InstallerApiFp(configuration)
        .v2ListFeatureSupportLevels(options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Retrieves the list of OpenShift hosts that belong the infra-env.
     * @param {string} infraEnvId The infra-env that the hosts are asociated with.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2ListHosts(
      infraEnvId: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<HostList>> {
      return InstallerApiFp(configuration)
        .v2ListHosts(infraEnvId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Lists operators to be monitored for a cluster.
     * @param {string} clusterId The cluster to return operators for.
     * @param {string} [operatorName] An operator in the specified cluster to return its data.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2ListOfClusterOperators(
      clusterId: string,
      operatorName?: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<MonitoredOperatorsList>> {
      return InstallerApiFp(configuration)
        .v2ListOfClusterOperators(clusterId, operatorName, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Posts the result of the operations from the host agent.
     * @param {string} infraEnvId The infra-env of the host that is posting results.
     * @param {string} hostId The host that is posting results.
     * @param {StepReply} [body] The results to be posted.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is posting results.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2PostStepReply(
      infraEnvId: string,
      hostId: string,
      body?: StepReply,
      discoveryAgentVersion?: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<void>> {
      return InstallerApiFp(configuration)
        .v2PostStepReply(infraEnvId, hostId, body, discoveryAgentVersion, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Creates a new OpenShift cluster definition.
     * @param {ClusterCreateParams} body The properties describing the new cluster.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2RegisterCluster(
      body: ClusterCreateParams,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Cluster>> {
      return InstallerApiFp(configuration)
        .v2RegisterCluster(body, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Registers a new OpenShift agent.
     * @param {HostCreateParams} body The description of the agent being registered.
     * @param {string} infraEnvId The infra-env that the agent is associated with.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is registering the agent.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2RegisterHost(
      body: HostCreateParams,
      infraEnvId: string,
      discoveryAgentVersion?: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<HostRegistrationResponse>> {
      return InstallerApiFp(configuration)
        .v2RegisterHost(body, infraEnvId, discoveryAgentVersion, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Controller API to report of monitored operators.
     * @param {OperatorMonitorReport} body The operators monitor report.
     * @param {string} clusterId The cluster whose operators are being monitored.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2ReportMonitoredOperatorStatus(
      body: OperatorMonitorReport,
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<void>> {
      return InstallerApiFp(configuration)
        .v2ReportMonitoredOperatorStatus(body, clusterId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Resets a failed installation.
     * @param {string} clusterId The cluster whose installation is to be reset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2ResetCluster(
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Cluster>> {
      return InstallerApiFp(configuration)
        .v2ResetCluster(clusterId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * reset a failed host for day2 cluster.
     * @param {string} infraEnvId The infra-env of the host that is being reset.
     * @param {string} hostId The host that is being reset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2ResetHost(
      infraEnvId: string,
      hostId: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Host>> {
      return InstallerApiFp(configuration)
        .v2ResetHost(infraEnvId, hostId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Reset failed host validation. It may be performed on any host validation with persistent validation result.
     * @summary Reset failed host validation.
     * @param {string} infraEnvId The infra-env of the host that its validation is being reset.
     * @param {string} hostId The host that its validation is being reset.
     * @param {string} validationId The id of the validation being reset.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2ResetHostValidation(
      infraEnvId: string,
      hostId: string,
      validationId: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Host>> {
      return InstallerApiFp(configuration)
        .v2ResetHostValidation(infraEnvId, hostId, validationId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Register the validations which are to be ignored for this cluster.
     * @param {IgnoredValidations} body The validations to be ignored.
     * @param {string} clusterId The cluster whose failing validations should be ignored according to this list.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2SetIgnoredValidations(
      body: IgnoredValidations,
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<IgnoredValidations>> {
      return InstallerApiFp(configuration)
        .v2SetIgnoredValidations(body, clusterId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Updates an OpenShift cluster definition.
     * @param {V2ClusterUpdateParams} body The properties to update.
     * @param {string} clusterId The cluster to be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2UpdateCluster(
      body: V2ClusterUpdateParams,
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Cluster>> {
      return InstallerApiFp(configuration)
        .v2UpdateCluster(body, clusterId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Override values in the install config.
     * @param {string} body Install config overrides.
     * @param {string} clusterId The cluster whose install config is being updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2UpdateClusterInstallConfig(
      body: string,
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<void>> {
      return InstallerApiFp(configuration)
        .v2UpdateClusterInstallConfig(body, clusterId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update log collection state and progress.
     * @param {LogsProgressParams} body Parameters for updating log progress.
     * @param {string} clusterId The cluster whose log progress is being updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2UpdateClusterLogsProgress(
      body: LogsProgressParams,
      clusterId: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<void>> {
      return InstallerApiFp(configuration)
        .v2UpdateClusterLogsProgress(body, clusterId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update an Openshift host
     * @param {HostUpdateParams} body The properties to update.
     * @param {string} infraEnvId The infra-env ID of the host to be updated.
     * @param {string} hostId The host that should be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2UpdateHost(
      body: HostUpdateParams,
      infraEnvId: string,
      hostId: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Host>> {
      return InstallerApiFp(configuration)
        .v2UpdateHost(body, infraEnvId, hostId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Patch the ignition file for this host
     * @param {HostIgnitionParams} body Ignition config overrides.
     * @param {string} infraEnvId The infra-env of the host whose ignition file should be updated.
     * @param {string} hostId The host whose ignition file should be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2UpdateHostIgnition(
      body: HostIgnitionParams,
      infraEnvId: string,
      hostId: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<void>> {
      return InstallerApiFp(configuration)
        .v2UpdateHostIgnition(body, infraEnvId, hostId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update installation progress.
     * @param {HostProgress} body New progress value.
     * @param {string} infraEnvId The infra-env of the host being updated.
     * @param {string} hostId The ID of the host to update.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is updating progress.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2UpdateHostInstallProgress(
      body: HostProgress,
      infraEnvId: string,
      hostId: string,
      discoveryAgentVersion?: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<void>> {
      return InstallerApiFp(configuration)
        .v2UpdateHostInstallProgress(body, infraEnvId, hostId, discoveryAgentVersion, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Updates a host's installer arguments.
     * @param {InstallerArgsParams} body The updated installer arguments.
     * @param {string} infraEnvId The infra-env of the host whose installer arguments should be updated.
     * @param {string} hostId The host whose installer arguments should be updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2UpdateHostInstallerArgs(
      body: InstallerArgsParams,
      infraEnvId: string,
      hostId: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<Host>> {
      return InstallerApiFp(configuration)
        .v2UpdateHostInstallerArgs(body, infraEnvId, hostId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Update log collection state and progress.
     * @param {LogsProgressParams} body Parameters for updating log progress.
     * @param {string} infraEnvId The infra-env whose log progress is being updated.
     * @param {string} hostId The host whose log progress is being updated.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2UpdateHostLogsProgress(
      body: LogsProgressParams,
      infraEnvId: string,
      hostId: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<void>> {
      return InstallerApiFp(configuration)
        .v2UpdateHostLogsProgress(body, infraEnvId, hostId, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Transfer the ingress certificate for the cluster.
     * @param {string} body The ingress certificate.
     * @param {string} clusterId The cluster to associate with the ingress certificate.
     * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is uploading the ingress certificate.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2UploadClusterIngressCert(
      body: string,
      clusterId: string,
      discoveryAgentVersion?: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<void>> {
      return InstallerApiFp(configuration)
        .v2UploadClusterIngressCert(body, clusterId, discoveryAgentVersion, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Agent API to upload logs.
     * @param {string} logsType The type of log file to be uploaded.
     * @param {string} clusterId The cluster whose logs should be uploaded.
     * @param {Blob} [upfile]
     * @param {string} [infraEnvId] The infra-env ID of the host.
     * @param {string} [hostId] The host whose logs should be uploaded.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async v2UploadLogsForm(
      logsType: string,
      clusterId: string,
      upfile?: Blob,
      infraEnvId?: string,
      hostId?: string,
      options?: AxiosRequestConfig,
    ): Promise<AxiosResponse<void>> {
      return InstallerApiFp(configuration)
        .v2UploadLogsForm(logsType, clusterId, upfile, infraEnvId, hostId, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * InstallerApi - object-oriented interface
 * @export
 * @class InstallerApi
 * @extends {BaseAPI}
 */
export class InstallerApi extends BaseAPI {
  /**
   * Bind host to a cluster
   * @param {BindHostParams} body The parameters for the host binding.
   * @param {string} infraEnvId The infra-env of the host that is being bound.
   * @param {string} hostId The host that is being bound.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async bindHost(
    body: BindHostParams,
    infraEnvId: string,
    hostId: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Host>> {
    return InstallerApiFp(this.configuration)
      .bindHost(body, infraEnvId, hostId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes an infra-env.
   * @param {string} infraEnvId The infra-env to be deleted.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async deregisterInfraEnv(
    infraEnvId: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<void>> {
    return InstallerApiFp(this.configuration)
      .deregisterInfraEnv(infraEnvId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get the initial ramdisk for minimal ISO based installations.
   * @param {string} infraEnvId The infra-env of the host that should be retrieved.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async downloadMinimalInitrd(
    infraEnvId: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Blob>> {
    return InstallerApiFp(this.configuration)
      .downloadMinimalInitrd(infraEnvId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * A list of platforms that this cluster can support in its current configuration.
   * @param {string} clusterId The cluster whose platform types should be retrieved.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async getClusterSupportedPlatforms(
    clusterId: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Array<PlatformType>>> {
    return InstallerApiFp(this.configuration)
      .getClusterSupportedPlatforms(clusterId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Retrieves the details of the infra-env.
   * @param {string} infraEnvId The infra-env to be retrieved.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async getInfraEnv(
    infraEnvId: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<InfraEnv>> {
    return InstallerApiFp(this.configuration)
      .getInfraEnv(infraEnvId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Creates a new pre-signed image download URL for the infra-env.
   * @param {string} infraEnvId The infra-env to be retrieved.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async getInfraEnvDownloadURL(
    infraEnvId: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<PresignedUrl>> {
    return InstallerApiFp(this.configuration)
      .getInfraEnvDownloadURL(infraEnvId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Creates a new pre-signed download URL for the infra-env.
   * @param {string} infraEnvId The file&#x27;s infra-env.
   * @param {string} fileName The file to be downloaded.
   * @param {string} [ipxeScriptType] Specify the script type to be served for iPXE.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async getInfraEnvPresignedFileURL(
    infraEnvId: string,
    fileName: string,
    ipxeScriptType?: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<PresignedUrl>> {
    return InstallerApiFp(this.configuration)
      .getInfraEnvPresignedFileURL(infraEnvId, fileName, ipxeScriptType, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Retrieves the architecture support-levels for each OpenShift version.
   * @param {string} openshiftVersion Version of the OpenShift cluster.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async getSupportedArchitectures(
    openshiftVersion: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<InlineResponse2001>> {
    return InstallerApiFp(this.configuration)
      .getSupportedArchitectures(openshiftVersion, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Retrieves the features support levels for each OpenShift version.
   * @param {string} openshiftVersion Version of the OpenShift cluster.
   * @param {string} [cpuArchitecture] The CPU architecture of the image (x86_64/arm64/etc).
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async getSupportedFeatures(
    openshiftVersion: string,
    cpuArchitecture?: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<InlineResponse200>> {
    return InstallerApiFp(this.configuration)
      .getSupportedFeatures(openshiftVersion, cpuArchitecture, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get a list of cluster hosts according to supplied filters.
   * @param {string} clusterId The cluster whose hosts should be retrieved.
   * @param {string} [role] Role to request.
   * @param {string} [status] Hosts status to request.
   * @param {boolean} [withInventory] If true return the host&#x27;s inventory.
   * @param {boolean} [withConnectivity] If true return the host&#x27;s connectivity.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async listClusterHosts(
    clusterId: string,
    role?: string,
    status?: string,
    withInventory?: boolean,
    withConnectivity?: boolean,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<HostList>> {
    return InstallerApiFp(this.configuration)
      .listClusterHosts(clusterId, role, status, withInventory, withConnectivity, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Retrieves the list of infra-envs.
   * @param {string} [clusterId] If provided, returns only infra-envs which directly reference this cluster.
   * @param {string} [owner] If provided, returns only infra-envs that are owned by the specified user.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async listInfraEnvs(
    clusterId?: string,
    owner?: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<InfraEnvList>> {
    return InstallerApiFp(this.configuration)
      .listInfraEnvs(clusterId, owner, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Regenerate InfraEnv token signing key.
   * @param {string} infraEnvId The target InfraEnv.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async regenerateInfraEnvSigningKey(
    infraEnvId: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<void>> {
    return InstallerApiFp(this.configuration)
      .regenerateInfraEnvSigningKey(infraEnvId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Creates a new OpenShift Discovery ISO.
   * @param {InfraEnvCreateParams} body The parameters for the generated ISO.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async registerInfraEnv(
    body: InfraEnvCreateParams,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<InfraEnv>> {
    return InstallerApiFp(this.configuration)
      .registerInfraEnv(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Transforms installed cluster to a state which allows adding hosts.
   * @param {string} clusterId The cluster to transform.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async transformClusterToAddingHosts(
    clusterId: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Cluster>> {
    return InstallerApiFp(this.configuration)
      .transformClusterToAddingHosts(clusterId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deprecated, maintained for legacy purposes. Does the same thing as allow-add-hosts. Use allow-add-hosts instead.
   * @param {string} clusterId The cluster to transform.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async transformClusterToDay2(
    clusterId: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Cluster>> {
    return InstallerApiFp(this.configuration)
      .transformClusterToDay2(clusterId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Unbind host to a cluster
   * @param {string} infraEnvId The infra-env of the host that is being bound.
   * @param {string} hostId The host that is being bound.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async unbindHost(
    infraEnvId: string,
    hostId: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Host>> {
    return InstallerApiFp(this.configuration)
      .unbindHost(infraEnvId, hostId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Updates an infra-env.
   * @param {InfraEnvUpdateParams} body The properties to update.
   * @param {string} infraEnvId The infra-env to be updated.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async updateInfraEnv(
    body: InfraEnvUpdateParams,
    infraEnvId: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<InfraEnv>> {
    return InstallerApiFp(this.configuration)
      .updateInfraEnv(body, infraEnvId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Cancels an ongoing installation.
   * @param {string} clusterId The cluster whose installation is to be canceled.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2CancelInstallation(
    clusterId: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Cluster>> {
    return InstallerApiFp(this.configuration)
      .v2CancelInstallation(clusterId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Agent API to mark a finalizing installation as complete and progress to 100%.
   * @param {CompletionParams} body The final status of the cluster installation.
   * @param {string} clusterId The cluster whose installation is being completing.
   * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is completing the installation.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2CompleteInstallation(
    body: CompletionParams,
    clusterId: string,
    discoveryAgentVersion?: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Cluster>> {
    return InstallerApiFp(this.configuration)
      .v2CompleteInstallation(body, clusterId, discoveryAgentVersion, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deletes an OpenShift cluster definition.
   * @param {string} clusterId The cluster to be deregistered.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2DeregisterCluster(
    clusterId: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<void>> {
    return InstallerApiFp(this.configuration)
      .v2DeregisterCluster(clusterId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Deregisters an OpenShift host.
   * @param {string} infraEnvId The infra-env of the host that should be deregistered.
   * @param {string} hostId The host that should be deregistered.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2DeregisterHost(
    infraEnvId: string,
    hostId: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<void>> {
    return InstallerApiFp(this.configuration)
      .v2DeregisterHost(infraEnvId, hostId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Downloads credentials relating to the installed/installing cluster.
   * @param {string} clusterId The cluster that owns the credential file that should be downloaded.
   * @param {string} fileName The credential file to be downloaded.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2DownloadClusterCredentials(
    clusterId: string,
    fileName: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Blob>> {
    return InstallerApiFp(this.configuration)
      .v2DownloadClusterCredentials(clusterId, fileName, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Downloads files relating to the installed/installing cluster.
   * @param {string} clusterId The cluster that owns the file that should be downloaded.
   * @param {string} fileName The file to be downloaded.
   * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is downloading the file.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2DownloadClusterFiles(
    clusterId: string,
    fileName: string,
    discoveryAgentVersion?: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Blob>> {
    return InstallerApiFp(this.configuration)
      .v2DownloadClusterFiles(clusterId, fileName, discoveryAgentVersion, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Download cluster logs.
   * @param {string} clusterId The cluster whose logs should be downloaded.
   * @param {string} [logsType] The type of logs to be downloaded.
   * @param {string} [hostId] A specific host in the cluster whose logs should be downloaded.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2DownloadClusterLogs(
    clusterId: string,
    logsType?: string,
    hostId?: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Blob>> {
    return InstallerApiFp(this.configuration)
      .v2DownloadClusterLogs(clusterId, logsType, hostId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Downloads the customized ignition file for this bound host, produces octet stream. For unbound host - error is returned
   * @param {string} infraEnvId The infra-env of the host whose ignition file should be downloaded.
   * @param {string} hostId The host whose ignition file should be downloaded.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2DownloadHostIgnition(
    infraEnvId: string,
    hostId: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Blob>> {
    return InstallerApiFp(this.configuration)
      .v2DownloadHostIgnition(infraEnvId, hostId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Downloads the customized ignition file for this host
   * @param {string} infraEnvId The infra-env whose file should be downloaded.
   * @param {string} fileName The file to be downloaded.
   * @param {string} [mac] Mac address of the host running ipxe script.
   * @param {string} [ipxeScriptType] Specify the script type to be served for iPXE.
   * @param {string} [discoveryIsoType] Overrides the ISO type for the disovery ignition, either &#x27;full-iso&#x27; or &#x27;minimal-iso&#x27;.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2DownloadInfraEnvFiles(
    infraEnvId: string,
    fileName: string,
    mac?: string,
    ipxeScriptType?: string,
    discoveryIsoType?: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Blob>> {
    return InstallerApiFp(this.configuration)
      .v2DownloadInfraEnvFiles(infraEnvId, fileName, mac, ipxeScriptType, discoveryIsoType, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Retrieves the details of the OpenShift cluster.
   * @param {string} clusterId The cluster to be retrieved.
   * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is retrieving the cluster details.
   * @param {boolean} [getUnregisteredClusters] Whether to return clusters that have been unregistered.
   * @param {boolean} [excludeHosts] If true, do not include hosts.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2GetCluster(
    clusterId: string,
    discoveryAgentVersion?: string,
    getUnregisteredClusters?: boolean,
    excludeHosts?: boolean,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Cluster>> {
    return InstallerApiFp(this.configuration)
      .v2GetCluster(
        clusterId,
        discoveryAgentVersion,
        getUnregisteredClusters,
        excludeHosts,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get the default values for various cluster properties.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2GetClusterDefaultConfig(
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<ClusterDefaultConfig>> {
    return InstallerApiFp(this.configuration)
      .v2GetClusterDefaultConfig(options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get the cluster's install config YAML.
   * @param {string} clusterId The cluster whose install config is being retrieved.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2GetClusterInstallConfig(
    clusterId: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<string>> {
    return InstallerApiFp(this.configuration)
      .v2GetClusterInstallConfig(clusterId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get the cluster admin credentials.
   * @param {string} clusterId The cluster whose admin credentials should be retrieved.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2GetCredentials(
    clusterId: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Credentials>> {
    return InstallerApiFp(this.configuration)
      .v2GetCredentials(clusterId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Retrieves the details of the OpenShift host.
   * @param {string} infraEnvId The infra-env of the host that should be retrieved.
   * @param {string} hostId The host that should be retrieved.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2GetHost(
    infraEnvId: string,
    hostId: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Host>> {
    return InstallerApiFp(this.configuration)
      .v2GetHost(infraEnvId, hostId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Fetch the ignition file for this host as a string. In case of unbound host produces an error
   * @param {string} infraEnvId The infra-env of the host whose ignition file should be obtained.
   * @param {string} hostId The host whose ignition file should be obtained.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2GetHostIgnition(
    infraEnvId: string,
    hostId: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<HostIgnitionParams>> {
    return InstallerApiFp(this.configuration)
      .v2GetHostIgnition(infraEnvId, hostId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Fetch the validations which are to be ignored for this cluster.
   * @param {string} clusterId The cluster whose failing validations should be ignored according to this list.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2GetIgnoredValidations(
    clusterId: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<IgnoredValidations>> {
    return InstallerApiFp(this.configuration)
      .v2GetIgnoredValidations(clusterId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Retrieves the next operations that the host agent needs to perform.
   * @param {string} infraEnvId The infra-env of the host that is retrieving instructions.
   * @param {string} hostId The host that is retrieving instructions.
   * @param {number} [timestamp] The time on the host as seconds since the Unix epoch.
   * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is retrieving instructions.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2GetNextSteps(
    infraEnvId: string,
    hostId: string,
    timestamp?: number,
    discoveryAgentVersion?: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Steps>> {
    return InstallerApiFp(this.configuration)
      .v2GetNextSteps(infraEnvId, hostId, timestamp, discoveryAgentVersion, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get preflight requirements for a cluster.
   * @param {string} clusterId The cluster to return preflight requirements for.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2GetPreflightRequirements(
    clusterId: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<PreflightHardwareRequirements>> {
    return InstallerApiFp(this.configuration)
      .v2GetPreflightRequirements(clusterId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Get the cluster admin credentials.
   * @param {string} clusterId The cluster that owns the file that should be downloaded.
   * @param {string} fileName The file to be downloaded.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2GetPresignedForClusterCredentials(
    clusterId: string,
    fileName: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<PresignedUrl>> {
    return InstallerApiFp(this.configuration)
      .v2GetPresignedForClusterCredentials(clusterId, fileName, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Retrieves a pre-signed S3 URL for downloading cluster files.
   * @param {string} clusterId The cluster that owns the file that should be downloaded.
   * @param {string} fileName The file to be downloaded.
   * @param {string} [logsType] If downloading logs, the type of logs to download.
   * @param {string} [hostId] If downloading a file related to a host, the relevant host.
   * @param {string} [additionalName] If downloading a manifest, the file name, prefaced with folder name, for example, openshift/99-openshift-xyz.yaml.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2GetPresignedForClusterFiles(
    clusterId: string,
    fileName: string,
    logsType?: string,
    hostId?: string,
    additionalName?: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<PresignedUrl>> {
    return InstallerApiFp(this.configuration)
      .v2GetPresignedForClusterFiles(clusterId, fileName, logsType, hostId, additionalName, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Import an AI cluster using minimal data associated with existing OCP cluster, in order to allow adding day2 hosts to that cluster
   * @param {ImportClusterParams} body Parameters for importing a OCP cluster for adding nodes.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2ImportCluster(
    body: ImportClusterParams,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Cluster>> {
    return InstallerApiFp(this.configuration)
      .v2ImportCluster(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Installs the OpenShift cluster.
   * @param {string} clusterId The cluster to be installed.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2InstallCluster(
    clusterId: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Cluster>> {
    return InstallerApiFp(this.configuration)
      .v2InstallCluster(clusterId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * install specific host for day2 cluster.
   * @param {string} infraEnvId The infra-env of the host that is being installed.
   * @param {string} hostId The host that is being installed.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2InstallHost(
    infraEnvId: string,
    hostId: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Host>> {
    return InstallerApiFp(this.configuration)
      .v2InstallHost(infraEnvId, hostId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Retrieves the list of OpenShift clusters.
   * @param {boolean} [getUnregisteredClusters] Whether to return clusters that have been unregistered.
   * @param {string} [openshiftClusterId] A specific cluster to retrieve.
   * @param {Array<string>} [amsSubscriptionIds] If non-empty, returned Clusters are filtered to those with matching subscription IDs.
   * @param {boolean} [withHosts] Include hosts in the returned list.
   * @param {string} [owner] If provided, returns only clusters that are owned by the specified user.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2ListClusters(
    getUnregisteredClusters?: boolean,
    openshiftClusterId?: string,
    amsSubscriptionIds?: Array<string>,
    withHosts?: boolean,
    owner?: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<ClusterList>> {
    return InstallerApiFp(this.configuration)
      .v2ListClusters(
        getUnregisteredClusters,
        openshiftClusterId,
        amsSubscriptionIds,
        withHosts,
        owner,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * (DEPRECATED) Retrieves the support levels for features for each OpenShift version.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2ListFeatureSupportLevels(
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<FeatureSupportLevels>> {
    return InstallerApiFp(this.configuration)
      .v2ListFeatureSupportLevels(options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Retrieves the list of OpenShift hosts that belong the infra-env.
   * @param {string} infraEnvId The infra-env that the hosts are asociated with.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2ListHosts(
    infraEnvId: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<HostList>> {
    return InstallerApiFp(this.configuration)
      .v2ListHosts(infraEnvId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Lists operators to be monitored for a cluster.
   * @param {string} clusterId The cluster to return operators for.
   * @param {string} [operatorName] An operator in the specified cluster to return its data.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2ListOfClusterOperators(
    clusterId: string,
    operatorName?: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<MonitoredOperatorsList>> {
    return InstallerApiFp(this.configuration)
      .v2ListOfClusterOperators(clusterId, operatorName, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Posts the result of the operations from the host agent.
   * @param {string} infraEnvId The infra-env of the host that is posting results.
   * @param {string} hostId The host that is posting results.
   * @param {StepReply} [body] The results to be posted.
   * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is posting results.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2PostStepReply(
    infraEnvId: string,
    hostId: string,
    body?: StepReply,
    discoveryAgentVersion?: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<void>> {
    return InstallerApiFp(this.configuration)
      .v2PostStepReply(infraEnvId, hostId, body, discoveryAgentVersion, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Creates a new OpenShift cluster definition.
   * @param {ClusterCreateParams} body The properties describing the new cluster.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2RegisterCluster(
    body: ClusterCreateParams,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Cluster>> {
    return InstallerApiFp(this.configuration)
      .v2RegisterCluster(body, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Registers a new OpenShift agent.
   * @param {HostCreateParams} body The description of the agent being registered.
   * @param {string} infraEnvId The infra-env that the agent is associated with.
   * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is registering the agent.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2RegisterHost(
    body: HostCreateParams,
    infraEnvId: string,
    discoveryAgentVersion?: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<HostRegistrationResponse>> {
    return InstallerApiFp(this.configuration)
      .v2RegisterHost(body, infraEnvId, discoveryAgentVersion, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Controller API to report of monitored operators.
   * @param {OperatorMonitorReport} body The operators monitor report.
   * @param {string} clusterId The cluster whose operators are being monitored.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2ReportMonitoredOperatorStatus(
    body: OperatorMonitorReport,
    clusterId: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<void>> {
    return InstallerApiFp(this.configuration)
      .v2ReportMonitoredOperatorStatus(body, clusterId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Resets a failed installation.
   * @param {string} clusterId The cluster whose installation is to be reset.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2ResetCluster(
    clusterId: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Cluster>> {
    return InstallerApiFp(this.configuration)
      .v2ResetCluster(clusterId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * reset a failed host for day2 cluster.
   * @param {string} infraEnvId The infra-env of the host that is being reset.
   * @param {string} hostId The host that is being reset.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2ResetHost(
    infraEnvId: string,
    hostId: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Host>> {
    return InstallerApiFp(this.configuration)
      .v2ResetHost(infraEnvId, hostId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Reset failed host validation. It may be performed on any host validation with persistent validation result.
   * @summary Reset failed host validation.
   * @param {string} infraEnvId The infra-env of the host that its validation is being reset.
   * @param {string} hostId The host that its validation is being reset.
   * @param {string} validationId The id of the validation being reset.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2ResetHostValidation(
    infraEnvId: string,
    hostId: string,
    validationId: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Host>> {
    return InstallerApiFp(this.configuration)
      .v2ResetHostValidation(infraEnvId, hostId, validationId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Register the validations which are to be ignored for this cluster.
   * @param {IgnoredValidations} body The validations to be ignored.
   * @param {string} clusterId The cluster whose failing validations should be ignored according to this list.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2SetIgnoredValidations(
    body: IgnoredValidations,
    clusterId: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<IgnoredValidations>> {
    return InstallerApiFp(this.configuration)
      .v2SetIgnoredValidations(body, clusterId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Updates an OpenShift cluster definition.
   * @param {V2ClusterUpdateParams} body The properties to update.
   * @param {string} clusterId The cluster to be updated.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2UpdateCluster(
    body: V2ClusterUpdateParams,
    clusterId: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Cluster>> {
    return InstallerApiFp(this.configuration)
      .v2UpdateCluster(body, clusterId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Override values in the install config.
   * @param {string} body Install config overrides.
   * @param {string} clusterId The cluster whose install config is being updated.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2UpdateClusterInstallConfig(
    body: string,
    clusterId: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<void>> {
    return InstallerApiFp(this.configuration)
      .v2UpdateClusterInstallConfig(body, clusterId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Update log collection state and progress.
   * @param {LogsProgressParams} body Parameters for updating log progress.
   * @param {string} clusterId The cluster whose log progress is being updated.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2UpdateClusterLogsProgress(
    body: LogsProgressParams,
    clusterId: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<void>> {
    return InstallerApiFp(this.configuration)
      .v2UpdateClusterLogsProgress(body, clusterId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Update an Openshift host
   * @param {HostUpdateParams} body The properties to update.
   * @param {string} infraEnvId The infra-env ID of the host to be updated.
   * @param {string} hostId The host that should be updated.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2UpdateHost(
    body: HostUpdateParams,
    infraEnvId: string,
    hostId: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Host>> {
    return InstallerApiFp(this.configuration)
      .v2UpdateHost(body, infraEnvId, hostId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Patch the ignition file for this host
   * @param {HostIgnitionParams} body Ignition config overrides.
   * @param {string} infraEnvId The infra-env of the host whose ignition file should be updated.
   * @param {string} hostId The host whose ignition file should be updated.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2UpdateHostIgnition(
    body: HostIgnitionParams,
    infraEnvId: string,
    hostId: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<void>> {
    return InstallerApiFp(this.configuration)
      .v2UpdateHostIgnition(body, infraEnvId, hostId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Update installation progress.
   * @param {HostProgress} body New progress value.
   * @param {string} infraEnvId The infra-env of the host being updated.
   * @param {string} hostId The ID of the host to update.
   * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is updating progress.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2UpdateHostInstallProgress(
    body: HostProgress,
    infraEnvId: string,
    hostId: string,
    discoveryAgentVersion?: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<void>> {
    return InstallerApiFp(this.configuration)
      .v2UpdateHostInstallProgress(body, infraEnvId, hostId, discoveryAgentVersion, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Updates a host's installer arguments.
   * @param {InstallerArgsParams} body The updated installer arguments.
   * @param {string} infraEnvId The infra-env of the host whose installer arguments should be updated.
   * @param {string} hostId The host whose installer arguments should be updated.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2UpdateHostInstallerArgs(
    body: InstallerArgsParams,
    infraEnvId: string,
    hostId: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<Host>> {
    return InstallerApiFp(this.configuration)
      .v2UpdateHostInstallerArgs(body, infraEnvId, hostId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Update log collection state and progress.
   * @param {LogsProgressParams} body Parameters for updating log progress.
   * @param {string} infraEnvId The infra-env whose log progress is being updated.
   * @param {string} hostId The host whose log progress is being updated.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2UpdateHostLogsProgress(
    body: LogsProgressParams,
    infraEnvId: string,
    hostId: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<void>> {
    return InstallerApiFp(this.configuration)
      .v2UpdateHostLogsProgress(body, infraEnvId, hostId, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Transfer the ingress certificate for the cluster.
   * @param {string} body The ingress certificate.
   * @param {string} clusterId The cluster to associate with the ingress certificate.
   * @param {string} [discoveryAgentVersion] The software version of the discovery agent that is uploading the ingress certificate.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2UploadClusterIngressCert(
    body: string,
    clusterId: string,
    discoveryAgentVersion?: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<void>> {
    return InstallerApiFp(this.configuration)
      .v2UploadClusterIngressCert(body, clusterId, discoveryAgentVersion, options)
      .then((request) => request(this.axios, this.basePath));
  }
  /**
   * Agent API to upload logs.
   * @param {string} logsType The type of log file to be uploaded.
   * @param {string} clusterId The cluster whose logs should be uploaded.
   * @param {Blob} [upfile]
   * @param {string} [infraEnvId] The infra-env ID of the host.
   * @param {string} [hostId] The host whose logs should be uploaded.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof InstallerApi
   */
  public async v2UploadLogsForm(
    logsType: string,
    clusterId: string,
    upfile?: Blob,
    infraEnvId?: string,
    hostId?: string,
    options?: AxiosRequestConfig,
  ): Promise<AxiosResponse<void>> {
    return InstallerApiFp(this.configuration)
      .v2UploadLogsForm(logsType, clusterId, upfile, infraEnvId, hostId, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
